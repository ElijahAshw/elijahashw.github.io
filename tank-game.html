<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank game</title>
    <style>
        body {
            background-color: #252525;
        }

        canvas {
            outline: 0px solid transparent;
        }
    </style>
</head>

<body>
    <canvas id="game-canvas"></canvas>
    <!-- Credit to pamela for code to use ProcessingJS in a webpage 
     https: //www.khanacademy.org/computer-programming/processingjs-inside-webpages-template/5157014494511104-->

    <!-- Include the processing.js library -->
    <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
    <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script>

    <script>
        let blueStart = false;
        let tank1Score = 0, tank2Score = 0;
        let flagImgs = Object.create(null);
        // let width = 600, height = 500;
        // let mouseIsPressed = false;
        let canvas = document.querySelector("#game-canvas");
        // canvas.setAttribute("width", width + "px");
        // canvas.setAttribute("height", height + "px");

        const programCode = function (processingInstance) {
            const width = 600, height = 500;
            let pmouseY = 0, pmouseX = 0;
            processingInstance.size(width, height);
            processingInstance.angleMode = "radians";

            /**
             * 
             * Tank Game
             * 
             * Made by ElijahKen
             * 
            **/

            let numPlayers = 1;
            /*
                numPlayers = 2 is 2 humans playing
                numPlayers = 1 is human vs computer
                numPlayers = 0 is a computer battle
            */

            // Lets redo some pvector stuff to use radians
            processingInstance.PVector.prototype.heading = function () {
                return Math.atan2(this.y, this.x);
            };

            processingInstance.PVector.angleBetween = function (v1, v2) {
                return Math.acos(v1.dot(v2) / (v1.mag() * v2.mag()));
            };

            processingInstance.PVector.prototype.rotate = function (angle) {
                let newHeading = this.heading() + angle;
                let mag = this.mag();
                this.x = Math.cos(newHeading) * mag;
                this.y = Math.sin(newHeading) * mag;
            };

            /** Define "myRect" **/
            // Taken from my program https: //www.khanacademy.org/computer-programming/myrect-a-better-rectangle/4561505013776384
            function myRectMode(mode) {
                // Idea to store mode on the 'myRectMode' function from bob lyons program https: //www.khanacademy.org/computer-programming/handbook-of-collisions-and-interiors/5567955982876672
                myRectMode.mode = mode;
            }
            function myRect(x, y, w, h, r1, r2, r3, r4) {
                // kappa and processingInstance.bezier points adapted from bob lyons program
                // https: //www.khanacademy.org/computer-programming/bzier-circle-simple-as-1-2-3-4/1258627859
                let kappa = 4 / 3 * (Math.SQRT2 - 1);

                let ifNull = Object.constructor("a, b", "return a ?? b;");
                let sideMin = Math.min(Math.abs(w), Math.abs(h)) / 2;
                r1 = Math.min(ifNull(r1, 0), sideMin);
                r2 = Math.min(ifNull(r2, r1), sideMin);
                r3 = Math.min(ifNull(r3, r2), sideMin);
                r4 = Math.min(ifNull(r4, r3), sideMin);

                if (myRectMode.mode === CORNERS) {
                    // taken from println(processingInstance.rect)
                    w -= x;
                    h -= y;
                } else if (myRectMode.mode === processingInstance.CENTER) {
                    // taken from println(processingInstance.rect)
                    x -= w / 2;
                    y -= h / 2;
                } else if (myRectMode.mode === RADIUS) {
                    // taken from println(processingInstance.rect)
                    x -= w / 2;
                    y -= h / 2;
                    w *= 2;
                    h *= 2;
                }

                if (w < 0) {
                    w *= -1;
                    x -= w;
                }

                if (h < 0) {
                    h *= -1;
                    y -= h;
                }

                processingInstance.beginShape();
                if (r1 === 0 && r2 === 0 && r3 === 0 && r4 === 0) {
                    processingInstance.vertex(x, y + h / 2);
                    processingInstance.vertex(x, y);
                    processingInstance.vertex(x + w, y);
                    processingInstance.vertex(x + w, y + h);
                    processingInstance.vertex(x, y + h);
                    processingInstance.vertex(x, y + h / 2);
                } else {
                    processingInstance.vertex(x, y + h / 2);
                    processingInstance.vertex(x, y + r1);
                    processingInstance.bezierVertex(x, y - r1 * kappa + r1, x - r1 * kappa + r1, y, x + r1, y);
                    processingInstance.vertex(x + w - r2, y);
                    processingInstance.bezierVertex(x + w - r2 + r2 * kappa, y, x + w, y - r2 * kappa + r2, x + w, y + r2);
                    processingInstance.vertex(x + w, y + h - r3);
                    processingInstance.bezierVertex(x + w, y - r3 + r3 * kappa + h, x - r3 + r3 * kappa + w, y + h, x - r3 + w, y + h);
                    processingInstance.vertex(x + r4, y + h);
                    processingInstance.bezierVertex(x + r4 - r4 * kappa, y + h, x, y - r4 + r4 * kappa + h, x, y + h - r4);
                    processingInstance.vertex(x, y + h / 2);
                }
                processingInstance.endShape(processingInstance.CLOSE);
            }

            /** Define "skewImage" **/
            let skewImage = function (img, skewFunction) {
                let w = img.width, h = img.height, maxSkew = 0;
                skewFunction = skewFunction ||
                    function (x) { return 10 * (1 - Math.sin(x * Math.PI / (w / 2))); };
                for (let i = 0; i < w; i++) {
                    maxSkew = Math.max(maxSkew, skewFunction(i));
                }
                let newImage = processingInstance.createGraphics(w, h + maxSkew + 1, processingInstance.JAVA2D);
                newImage.background(0, 0, 0, 0);
                for (let x = 0; x < w; x++) {
                    let curHeight = skewFunction(x);
                    let floorY = Math.floor(curHeight);
                    let fraction = curHeight - Math.floor(curHeight);
                    fraction = Math.round(fraction * 100000) / 100000;
                    for (let y = -1; y < h; y++) {
                        let curY = floorY + y;
                        let here = img.get(x, y) || 0xffffff;
                        let there = img.get(x, y + 1) || 0xffffff;
                        newImage.stroke(newImage.lerpColor(there, here, fraction));
                        newImage.point(x, curY + 1);
                    }
                }
                return newImage;
            };

            /** Variables **/
            let gravity = new processingInstance.PVector(0, 2.3);
            let gameStarted = false;
            let gameEnd = false;
            let gameEnding = 300;
            let won = "No one\nwins yet.";
            let screenShift = 0;
            let cMouseX = null, cMouseY = null, shouldDrag = false;
            let gameScreens = [], lastShotScreens = [];
            let screens = gameScreens;
            blueStart = !blueStart;
            let left = 124, right = 526;
            let tankStartRange = 25;
            let numMissiles = 0, pnumMissiles = 0;
            let numTurns = 3, turn = 1;
            let screenNum = 0;
            let defaultImageX = 454, defaultImageY = 374,
                defaultImageScale = 2.7;
            let imageX = defaultImageX, imageY = defaultImageY,
                imageScale = defaultImageScale;
            let tank1, tank2;


            let ground5 = [
                207, 208, 208, 208, 209, 212, 213, 216, 218, 220, 221, 223, 225, 226, 228, 229, 231, 233, 239, 250, 256, 260, 263, 265, 268, 270, 271, 273, 274, 275, 277, 279, 281, 283, 284, 286, 289, 289, 289, 290, 291, 292, 293, 294, 294, 295, 296, 296, 296, 295, 295, 295, 295, 295, 294, 294, 293, 293, 293, 293, 292, 292, 291, 290, 290, 289, 289, 289, 286, 280, 277, 272, 268, 262, 259, 257, 256, 255, 253, 248, 246, 245, 244, 241, 239, 236, 235, 233, 232, 230, 229, 226, 225, 222, 221, 219, 218, 218, 218, 218, 219, 220, 221, 222, 222, 223, 225, 227, 228, 230, 234, 236, 237, 238, 241, 243, 244, 246, 248, 250, 252, 253, 255, 257, 259, 260, 263, 265, 271, 268, 272, 276, 279, 281, 282, 283, 284, 285, 286, 286, 287, 288, 289, 290, 290, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 290, 290, 289, 289, 288, 288, 286, 284, 281, 280, 278, 277, 275, 273, 268, 239, 237, 235, 232, 229, 227, 224, 222, 219, 217, 216, 215, 214, 214, 213, 213, 213, 213, 215, 216, 216, 217, 218, 221, 221, 221, 222, 224, 227, 229, 234, 236, 239, 243, 245, 246, 249, 252, 254, 257, 261, 265, 272, 276, 279, 281, 283, 283, 284, 284, 286, 286, 287, 287, 288, 288, 289, 289, 289, 290, 290, 290, 290, 290, 290, 289, 288, 286, 285, 284, 283, 282, 280, 278, 277, 277, 277, 276, 276, 275, 274, 272, 271, 270, 267, 264, 262, 254, 252, 251, 249, 248, 245, 242, 239, 234, 227, 223, 214, 212, 210, 208, 207, 206, 206, 206, 206, 205, 205, 205, 205, 205, 205, 205, 206, 206, 207, 208, 209, 210, 211, 213, 215, 218, 220, 224, 228, 230, 234, 236, 241, 246, 250, 252, 255, 260, 264, 267, 269, 271, 275, 276, 278, 281, 283, 286, 286, 286, 286, 287, 288, 288, 288, 288, 288, 288, 288, 287, 287, 287, 287, 286, 286, 286, 285, 284, 284, 283, 282, 281, 280, 279, 278, 277, 275, 274, 271, 268, 266, 263, 261, 259, 257, 254, 252, 249, 245, 241, 234, 230, 225, 223, 220, 216, 214, 213, 211, 210, 210, 210, 209, 209, 209, 209, 209, 209, 209, 209, 210, 210, 210, 211, 213, 215, 218, 221, 226, 238, 264, 267, 271, 275, 279, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 280, 280, 279, 279, 278, 277, 276, 272, 267, 265, 261, 259, 259, 255, 253, 246, 235, 232, 232, 230, 229, 227, 226, 225, 224, 222, 222, 218, 215, 214, 212, 210, 209, 207, 206, 205, 204, 204, 204, 204, 205, 204, 204, 204, 205, 206, 206, 207, 208, 209, 209, 210, 210, 211, 213, 228, 231, 251, 253, 258, 260, 263, 267, 268, 269, 270, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 269, 267, 263, 262, 259, 256, 253, 249, 247, 243, 230, 229, 228, 225, 223, 222, 217, 215, 213, 212, 211, 208, 205, 204, 204, 204, 203, 203, 203, 203, 202, 202, 201, 201, 200, 200, 200, 200, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 200, 200, 200, 201, 202, 202, 203, 205, 207, 210, 214, 216, 220, 223, 226, 228, 230, 234, 244, 248, 251, 255, 257, 260, 261, 262, 261, 261, 261, 260, 260, 260, 260, 260, 260, 259, 259, 259, 259, 259, 259, 259, 259, 259, 260, 261, 261, 262, 262, 262, 262, 262, 263, 263, 263, 263,
            ];
            let ground4 = [
                275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 276, 276, 276, 275, 275, 274, 274, 274, 273, 273, 272, 272, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 272, 272, 272, 272, 272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 273, 273, 273, 273, 272, 272, 271, 271, 271, 270, 270, 270, 270, 270, 270, 270, 270, 269, 269, 269, 269, 269, 269, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 269, 269, 269, 269, 269, 269, 270, 270, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272, 272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 272, 272, 271, 271, 271, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 271, 271, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 274, 274, 274, 273, 273, 272, 272, 271, 271, 271, 271, 271, 271, 271, 271, 271, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 270, 270, 270, 270, 270, 270, 269, 269, 269, 269, 269, 269, 268, 268, 268, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 265, 265, 265, 265, 265, 265, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 263, 263, 263, 263, 263, 263, 264, 264, 264, 264, 264, 264, 264, 264, 264, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 264, 264, 264, 264, 264, 264, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 264, 264, 263, 263, 263, 263, 263, 263, 263, 262, 262, 262, 262, 261, 261, 261, 260, 260, 260, 260, 260, 260, 259, 259, 259, 259, 259, 259, 259, 259, 259, 260, 261, 261, 262, 262, 262, 262, 262, 263, 263, 263, 263,
            ];
            let ground3 = [
                282, 280, 281, 282, 282, 283, 283, 283, 283, 284, 285, 285, 286, 286, 286, 287, 287, 287, 287, 287, 288, 288, 288, 289, 289, 289, 289, 289, 289, 290, 290, 290, 290, 290, 291, 291, 291, 291, 291, 291, 291, 291, 291, 292, 292, 292, 292, 292, 292, 292, 292, 293, 293, 293, 293, 293, 294, 294, 294, 294, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 294, 294, 294, 294, 294, 294, 294, 294, 294, 293, 293, 293, 293, 293, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 288, 288, 287, 287, 287, 286, 285, 285, 285, 285, 285, 285, 285, 284, 284, 284, 284, 283, 283, 282, 281, 281, 281, 280, 280, 279, 279, 279, 278, 277, 277, 277, 276, 276, 275, 275, 275, 275, 274, 273, 271, 270, 270, 269, 268, 267, 266, 265, 264, 261, 260, 260, 259, 259, 257, 256, 255, 254, 252, 251, 250, 250, 249, 247, 246, 246, 245, 243, 241, 240, 238, 235, 233, 232, 230, 229, 227, 224, 223, 221, 220, 218, 216, 216, 215, 212, 210, 208, 208, 207, 205, 204, 203, 202, 202, 201, 199, 197, 197, 196, 194, 193, 189, 188, 187, 183, 182, 180, 179, 179, 178, 177, 177, 177, 175, 173, 171, 170, 167, 166, 166, 164, 164, 164, 163, 161, 161, 158, 157, 156, 155, 154, 153, 152, 150, 150, 150, 149, 149, 147, 144, 143, 142, 140, 138, 137, 136, 135, 133, 133, 131, 131, 131, 130, 129, 129, 127, 127, 126, 125, 125, 125, 125, 124, 124, 123, 122, 122, 121, 121, 121, 120, 120, 120, 119, 119, 119, 118, 118, 118, 118, 118, 118, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 117, 117, 117, 117, 117, 118, 118, 118, 118, 119, 119, 120, 120, 121, 121, 122, 124, 126, 127, 129, 131, 132, 134, 136, 137, 137, 138, 140, 144, 146, 146, 147, 148, 148, 149, 150, 150, 152, 152, 154, 155, 157, 158, 160, 161, 163, 165, 166, 166, 167, 168, 169, 170, 170, 171, 172, 174, 174, 175, 176, 177, 177, 178, 178, 179, 179, 180, 180, 180, 181, 182, 183, 184, 185, 187, 187, 188, 189, 189, 190, 191, 191, 192, 192, 192, 192, 192, 193, 193, 193, 194, 195, 196, 197, 197, 198, 198, 199, 199, 200, 200, 201, 201, 202, 203, 204, 205, 206, 207, 208, 208, 209, 210, 211, 212, 212, 213, 214, 215, 215, 215, 217, 217, 218, 219, 220, 220, 221, 221, 222, 223, 224, 225, 226, 227, 229, 230, 231, 232, 233, 234, 235, 236, 236, 238, 239, 239, 240, 241, 242, 242, 243, 244, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 253, 254, 255, 256, 256, 257, 257, 258, 258, 258, 259, 259, 259, 259, 260, 260, 260, 260, 260, 260, 261, 261, 261, 262, 262, 262, 262, 262, 263, 263, 263, 263, 263, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 265, 265, 265, 265, 265, 265, 266, 266, 266, 266, 267, 267, 267, 267, 267, 267, 267, 266, 265, 265, 264, 263, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 262, 262, 262, 263, 263, 264, 264, 264, 265, 265, 265, 265,
            ];
            let ground2 = [
                279, 280, 281, 282, 282, 283, 283, 283, 283, 284, 285, 285, 286, 286, 286, 287, 287, 287, 287, 287, 288, 288, 288, 289, 289, 289, 289, 289, 289, 290, 290, 290, 290, 290, 291, 291, 291, 291, 291, 291, 291, 291, 291, 292, 292, 292, 292, 292, 292, 292, 292, 293, 293, 293, 293, 293, 294, 294, 294, 294, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 294, 294, 294, 294, 294, 294, 294, 294, 294, 293, 293, 293, 293, 293, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 288, 288, 287, 287, 287, 286, 285, 285, 285, 285, 285, 285, 285, 284, 284, 284, 284, 283, 283, 282, 281, 281, 281, 280, 280, 278, 278, 278, 278, 278, 277, 276, 273, 270, 269, 266, 261, 256, 252, 242, 234, 232, 230, 227, 220, 216, 212, 206, 201, 198, 194, 190, 186, 179, 176, 172, 167, 165, 162, 158, 155, 153, 149, 142, 138, 135, 132, 125, 120, 118, 117, 114, 110, 106, 102, 99, 94, 90, 89, 87, 86, 85, 85, 84, 84, 83, 82, 82, 82, 82, 82, 82, 82, 81, 81, 81, 81, 82, 83, 84, 85, 87, 87, 88, 90, 91, 93, 97, 100, 102, 105, 108, 110, 112, 114, 116, 117, 120, 121, 123, 125, 135, 138, 142, 146, 150, 153, 155, 159, 161, 165, 171, 173, 176, 179, 180, 183, 186, 189, 191, 193, 196, 198, 201, 204, 207, 210, 213, 215, 218, 220, 222, 225, 226, 227, 229, 231, 232, 233, 235, 237, 239, 241, 242, 244, 248, 252, 253, 256, 259, 260, 262, 263, 265, 266, 267, 268, 270, 271, 271, 272, 272, 273, 273, 274, 274, 275, 275, 276, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 277, 277, 277, 276, 276, 276, 276, 276, 276, 276, 275, 272, 269, 268, 267, 266, 264, 263, 261, 259, 258, 255, 254, 252, 250, 248, 245, 242, 240, 237, 235, 233, 231, 230, 229, 228, 228, 228, 226, 224, 222, 221, 219, 218, 217, 212, 211, 209, 206, 205, 205, 197, 194, 189, 187, 185, 183, 178, 176, 176, 174, 165, 163, 161, 160, 159, 157, 155, 153, 151, 149, 148, 145, 143, 142, 139, 137, 136, 132, 129, 127, 125, 124, 120, 119, 117, 114, 112, 110, 108, 107, 106, 104, 103, 101, 100, 99, 98, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 88, 90, 90, 90, 90, 92, 93, 93, 96, 98, 102, 105, 108, 114, 117, 124, 137, 141, 144, 151, 153, 157, 160, 167, 171, 175, 179, 186, 191, 194, 198, 202, 205, 207, 207, 209, 210, 211, 212, 214, 215, 216, 217, 219, 220, 221, 222, 224, 224, 225, 226, 228, 228, 229, 230, 231, 232, 233, 234, 235, 236, 236, 238, 239, 239, 240, 241, 242, 242, 243, 244, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 253, 254, 255, 256, 256, 257, 257, 258, 258, 258, 259, 259, 259, 259, 260, 260, 260, 260, 260, 260, 261, 261, 261, 262, 262, 262, 262, 262, 263, 263, 263, 263, 263, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 265, 265, 265, 265, 265, 265, 266, 266, 266, 266, 267, 267, 267, 267, 267, 267, 267, 266, 265, 265, 264, 263, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 262, 262, 262, 263, 263, 264, 264, 264, 265, 265, 265, 265,
            ];
            let ground1 = [
                182, 182, 182, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 183, 182, 182, 182, 182, 182, 183, 184, 185, 185, 186, 187, 188, 189, 189, 190, 191, 192, 192, 193, 194, 195, 196, 197, 199, 200, 201, 203, 204, 204, 206, 207, 207, 210, 210, 211, 213, 213, 215, 215, 216, 216, 217, 218, 218, 219, 220, 221, 222, 222, 223, 224, 224, 225, 226, 226, 226, 226, 226, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 226, 226, 226, 225, 224, 224, 223, 222, 221, 220, 220, 218, 214, 213, 212, 211, 210, 210, 209, 209, 207, 206, 205, 204, 204, 203, 203, 202, 201, 200, 198, 197, 196, 195, 194, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 182, 181, 181, 181, 179, 179, 177, 177, 176, 176, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 175, 175, 174, 174, 173, 173, 172, 172, 172, 170, 170, 169, 169, 169, 168, 168, 167, 167, 166, 166, 166, 165, 165, 165, 164, 164, 163, 162, 161, 160, 160, 160, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 160, 161, 162, 163, 165, 165, 168, 169, 170, 171, 171, 172, 173, 173, 174, 174, 174, 175, 175, 175, 176, 176, 176, 177, 177, 178, 179, 179, 180, 181, 181, 181, 182, 182, 182, 182, 182, 183, 183, 183, 183, 184, 184, 184, 184, 184, 184, 184, 184, 184, 184, 184, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 186, 187, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 199, 200, 202, 205, 208, 211, 213, 214, 216, 217, 218, 219, 221, 223, 225, 228, 229, 231, 233, 234, 236, 237, 238, 238, 238, 238, 238, 238, 238, 238, 238, 239, 239, 239, 240, 240, 240, 240, 240, 240, 240, 240, 239, 239, 239, 239, 238, 238, 238, 238, 238, 237, 236, 236, 236, 235, 235, 233, 233, 233, 232, 230, 230, 229, 229, 229, 228, 227, 225, 223, 222, 221, 221, 219, 219, 217, 214, 212, 207, 205, 204, 202, 200, 199, 199, 198, 197, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 198, 198, 198, 199, 199, 200, 201, 202, 204, 206, 207, 208, 210, 211, 212, 212, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 212, 211, 211, 210, 210, 209, 209, 208, 207, 207, 206, 205, 203, 202, 202, 201, 201, 200, 198, 198, 196, 195, 194, 194, 193, 193, 193, 192, 192, 192, 192, 192, 192, 192, 191, 191, 191, 191, 191, 191, 192, 192, 193, 194, 195, 196, 197, 198, 200, 201, 202, 202, 203, 203, 203, 203, 205, 205, 206, 207, 207, 208, 208, 210, 211, 211, 212, 213, 213, 214, 214, 215, 215, 216, 216, 217, 217, 218, 218, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 217, 217, 217, 217, 217, 217, 217, 216, 216, 216, 216, 216, 216, 216, 216, 215, 215, 215, 215, 214, 213, 213, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 211, 211, 210, 210, 210, 210, 210, 210, 209, 209, 209, 205, 205, 205, 203, 201, 200, 199, 199, 199, 199, 199, 200, 200, 200, 201, 201, 201,
            ];

            let grounds = [ground1, ground2, ground3, ground4, ground5];
            let ground = [];

            for (let i = 0; i < grounds.length; i++) {
                for (let j = 0; j < grounds[i].length; j++) {
                    grounds[i][j] = { x: j, y: grounds[i][j] };
                }
            }

            function chooseGround() {
                let num = Math.floor(processingInstance.random(0, grounds.length * 2));

                ground = grounds[num < grounds.length ? num : 0].map(col => Object.create(col));

                if (num >= grounds.length) {
                    let spot = Math.random() * 100000;

                    for (let i = 0; i <= width; i++) {
                        let h = processingInstance.noise(spot + i / 200) * 500;

                        ground[i] = { x: i, y: Math.round(h) };
                    }
                }
            }
            chooseGround();

            let missiles = [];
            let boxes = [];


            /** Global functions **/
            //method for removing an item from an array mimicked from bob lyon
            //https: //www.khanacademy.org/computer-programming/leak-free-particle-system/4684587452399616
            Array.prototype.del = function (ind, num) {
                let l = this.length;
                num = arguments.length < 2 ? l - ind : Math.max(num, 0);

                for (let i = ind; i < l - num; i++) {
                    this[i] = this[i + num];
                }

                for (let i = 0; i < num; i++) {
                    this.pop();
                }
            };

            function advanceTurn() {
                if (gameEnd) {
                    return;
                }

                let t1 = turn === 1 ? tank1 : tank2;
                let t2 = turn === 1 ? tank2 : tank1;

                t1.dragging = null;
                t1.driveConPos = 0;
                t1.displayMenu = false;
                t1.menuOff = 0;
                turn = turn % 2 + 1;
                t2.refill();
                if (++numTurns % 4 === (turn === 1 ? 3 : 2)) {
                    t2.dropBox();
                }
            }

            function checkTie() {
                if (tank1.shots.length + tank2.shots.length + boxes.length +
                    missiles.length === 0 && tank1.life > 0 && tank2.life > 0) {
                    won = "It's a tie!";
                    gameEnd = true;
                }
            }

            function accessG(i) {
                // This function does not get used for drawing the ground!

                let constrainedIndex = Math.min(Math.max(i, 0), ground.length - 1);

                if (constrainedIndex !== i) {
                    return { x: i, y: ground[constrainedIndex].y };
                }

                return ground[constrainedIndex];
            }

            function calcAvPixelHeight(x) {
                let g1 = accessG(Math.floor(x)).y;
                let g2 = accessG(Math.ceil(x)).y;

                return (g1 + g2) / 2;
            }

            // isInPolygon copied from Bob Lyon's program https: //en.khanacademy.org/computer-programming/handbook-of-collisions-and-interiors/5567955982876672
            function isInPolygon(x, y, poly) {
                var isIn = false;
                for (var i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    var xi = poly[i].x, yi = poly[i].y;
                    var xj = poly[j].x, yj = poly[j].y;
                    var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                    if (intersect) {
                        isIn = !isIn;
                    }
                }
                return isIn;
            }

            function rotate2D(nodes, theta) {
                let cosTheta = Math.cos(theta);
                let sinTheta = Math.sin(theta);

                for (let i = 0; i < nodes.length; i++) {
                    let node = nodes[i], pnodeX = node.x;

                    node.x = cosTheta * pnodeX - sinTheta * node.y;
                    node.y = sinTheta * pnodeX + cosTheta * node.y;
                }
            }

            function getCirclePoint(radius, angle) {
                let x = Math.cos(angle) * radius;
                let y = Math.sin(angle) * radius;

                return { x, y };
            }

            function calcLinePosY(x, x1, y1, x2, y2) {
                return processingInstance.map(x, x1, x2, y1, y2);
            }

            function constrain2(n, aMin, aMax) {
                return aMin > aMax || n < aMin ? aMin : n > aMax ? aMax : n;
            }

            function isBetween(test, num1, num2) {
                return num1 > test ? test >= num2 : test <= num2;
            }

            function empty() { }


            /** Box constructor **/
            const Box = (function () {
                // Constructor
                function Box(x) {
                    this.x = processingInstance.constrain(Math.round(x + processingInstance.random(-100, 100)), 10, width - 10);
                    this.y = 0;
                    this.onGround = false;
                    this.type = this.types[Math.floor(Math.random() * this.types.length)];
                }

                Box.prototype.types = ["fire pillar", "kamikaze", "giant", "add on", "life inc"];

                // Normal methods
                Object.assign(Box.prototype, {
                    draw: function () {
                        if (!this.onGround) {
                            let s = 12, x = this.x, y = this.y, h = 20;
                            processingInstance.stroke(0, 0, 0);
                            processingInstance.strokeWeight(1);
                            processingInstance.line(x, this.y - 9, x + 10, y - h);
                            processingInstance.line(x, this.y - 9, x - 10, y - h);
                            processingInstance.noStroke();
                            processingInstance.stroke(201, 201, 201);
                            processingInstance.fill(255, 255, 255);
                            processingInstance.strokeWeight(1.5);
                            processingInstance.arc(x, y - h, s * 2, s * 2, -Math.PI, 0);
                            processingInstance.fill(0, 0, 0, 0);
                            processingInstance.bezier(x, y - h - s, x + s * 43 / 100, y - h - s * 9 / 10,
                                x + s / 2, y - h - s * 2 / 5, x + s * 53 / 100, y - h);
                            processingInstance.bezier(x, y - h - s, x - s * 43 / 100, y - h - s * 9 / 10,
                                x - s / 2, y - h - s * 2 / 5, x - s * 53 / 100, y - h);
                            processingInstance.line(x, y - h - s, x, y - h);
                        }

                        processingInstance.strokeWeight(1);
                        processingInstance.stroke(0, 135, 70);
                        processingInstance.fill(0, 201, 104);
                        processingInstance.rect(this.x - 5, this.y, 10, -10);
                        processingInstance.line(this.x - 4, this.y - 9, this.x + 5, this.y);
                        processingInstance.line(this.x - 4, this.y, this.x + 5, this.y - 9);

                    },
                    move: function () {
                        if (!this.onGround) {
                            this.y += 1;
                        }

                        if (this.y >= accessG(this.x).y) {
                            this.y = accessG(this.x).y;
                            this.onGround = true;
                        } else {
                            this.onGround = false;
                        }
                    },
                    collect: function (tank) {
                        if (tank.life > 0) {
                            if (this.type === "life inc") {
                                tank.life = processingInstance.constrain(tank.life + 150, 0, 500);
                            } else {
                                tank.shots.unshift(this.type);
                                tank.curShot = tank.shots[0] || "";
                            }

                            boxes.del(boxes.indexOf(this), 1);
                        }
                    },
                    inRange: function (tankX, tankWidth) {
                        let tankY = accessG(Math.round(tankX)).y;
                        let dst = processingInstance.dist(tankX, tankY, this.x, this.y);
                        return dst < tankWidth / 2 + 10 / 2;
                    },
                    check: function () {
                        let t1 = turn === 1 ? tank1 : tank2;
                        let t2 = turn === 1 ? tank2 : tank1;
                        if (this.inRange(t1.x, t1.width)) {
                            this.collect(t1);
                        }
                        if (this.inRange(t2.x, t2.width)) {
                            this.collect(t2);
                        }
                    },
                });

                return Box;
            })();


            /** Missile constructor **/
            const Missile = (function () {
                // A function to draw an explosion (used in missileTypes)
                function drawExplosion() {
                    let size = this.exploding;

                    let minSize = processingInstance.max(size / 2, 0);

                    for (let r = 0; r < size - minSize; r += 1) {
                        let c1 = processingInstance.color(255, 255, 0);
                        let c2 = processingInstance.color(255, 127, 0);

                        processingInstance.noFill();
                        processingInstance.stroke(processingInstance.lerpColor(c1, c2, r / (size - minSize)));
                        processingInstance.strokeWeight(1.1);
                        processingInstance.ellipse(0, 0, minSize + r, minSize + r);
                    }
                }

                // The missile types!
                let missileTypes = {
                    "add on": {
                        advanceTurn: empty,
                        setSize: function () {
                            this.size = 100;
                        },
                        draw: function () {
                            let x = Math.round(this.position.x);
                            let y = this.position.y;

                            let s = this.size;

                            processingInstance.strokeWeight(1);
                            for (let i = 0; i < s; i++) {
                                let add = -s / 2 + i;

                                processingInstance.stroke(255, 170, 0);
                                processingInstance.line(add, accessG(Math.round(x + add)).y - y, add, accessG(Math.round(x + add)).y - 15 - y);
                            }
                        },
                        calDist: function (other) {
                            return Math.abs(this.position.x - other.x);
                        },
                        explode2: empty,
                    },
                    "fire pillar": {
                        setUp: function (m) {
                            this.pouring = 0;
                        },
                        setSize: function () {
                            this.size = 160;
                            this.exploding = 160;
                        },
                        draw: function () {
                            let x = this.position.x;
                            let y = this.position.y;

                            processingInstance.strokeWeight(1);
                            for (let i = 0; i < 30; i++) {
                                let add = -15 + i;
                                let h = this.calcCirclePos(add + x);

                                let c1 = processingInstance.color(255, 208, 0);
                                let c2 = processingInstance.color(255, 149, 0);
                                let num = Math.abs(add) / 30;

                                processingInstance.stroke(processingInstance.lerpColor(c1, c2, num));
                                processingInstance.line(add, -y - screenShift, add, h - y - 1.5);
                            }

                            let s = this.size;

                            for (let i = 0; i < s; i++) {
                                let add = -s / 2 + i;
                                let h = accessG(Math.round(add + x)).y;
                                let h2 = this.calcCirclePos(add + x);

                                processingInstance.stroke(255, 170, 0);
                                processingInstance.line(add, h - y, add, h2 - y - 8.5);
                            }
                        },
                        explode1: function () {
                            this.pouring += 5;
                        },
                        getDivAmount: function () {
                            return 7.7;
                        },
                        calDist: function (other) {
                            return Math.abs(this.position.x - other.x);
                        },
                        end: function () {
                            return this.pouring > 180;
                        },
                    },
                    "kamikaze": {
                        onHit: function () {
                            let x = Math.round(this.position.x);

                            for (let i = 0; i < 3; i++) {
                                let v = new processingInstance.PVector(0, 0.1);
                                let p = new processingInstance.PVector(x, 0);
                                let t = "medium";
                                let f = processingInstance.frameCount + i * 20;
                                let miss = new Missile(v, p, t, f);
                                try {
                                    miss.advanceTurn = empty;
                                } catch (err) {
                                    println(err);
                                }
                                missiles.push(miss);
                            }

                            return true;
                        }
                    },
                    "giant": {
                        setSize: function () {
                            this.size = 170;
                        },
                    },
                    "big": {
                        setSize: function () {
                            this.size = 100;
                        },
                    },
                    "bounce volley": {
                        setUp: function () {
                            let addMiss = new Array(0);

                            for (let i = 0; i < 19; i++) {
                                addMiss.push(new Missile(this.velosity, this.position, "bounce small", processingInstance.frameCount + i * 10));
                            }

                            return addMiss;
                        },
                    },
                    "super-volley": {
                        setUp: function () {
                            let addMiss = new Array(0);

                            for (let i = 0; i < 19; i++) {
                                addMiss.push(new Missile(this.velosity, this.position, "XXS", processingInstance.frameCount + i * 10));
                            }

                            return addMiss;
                        },
                    },
                    "top burn": {
                        setUp: function () {
                            this.rolling = 0;
                        },
                        setSize: function () {
                            this.size = 25;
                            this.exploding = 35;
                        },
                        explode1: function (m) {
                            if (this.velosity.x === 0) {
                                this.rolling += 1.7;
                            } else {
                                let dir = this.velosity.x < 0 ? -1 : 1;
                                this.rolling += 1.7 * dir;
                                this.position.x += 1.7 * dir;
                            }
                            let newY = accessG(Math.round(this.position.x)).y;
                            this.position.y = newY;
                        },
                        explode2: empty,
                        end: function () {
                            return Math.abs(this.rolling) >= 150 || this.position.x < 0 || this.position.x > width;
                        },
                    },
                    "line drive": {
                        setUp: function () {
                            this.moves = 0;
                        },
                        setSize: function () {
                            this.size = 75;
                        },
                        getAddGravity: function () {
                            return false;
                        },
                        move: function () {
                            let vel = processingInstance.PVector.div(this.velosity, 2);
                            this.position.add(vel);
                            this.moves += 0.5;

                            if (this.moves >= 7) {
                                this.exploded = true;
                                this.setSize();
                                this.advanceTurn();
                            }
                        },
                    },
                    "bounce": {
                        setUp: function () {
                            this.bounceTime = 50;
                        },
                        setSize: function () {
                            this.size = 75;
                        },
                        onHit: function (type) {
                            if (type === "edge") {
                                this.velosity.x *= -1;
                                this.exploded = false;
                                return "end";
                            } else if (this.frameC < this.bounceTime &&
                                type === "ground") {
                                this.exploded = false;
                                this.exploding = 0;
                                let x = this.position.x;
                                let v = this.velosity;
                                let g = new processingInstance.PVector(1, accessG(Math.ceil(x)).y - accessG(Math.ceil(x) - 1).y);
                                let vMag = v.mag();
                                let gAngle = g.heading();
                                let angle = processingInstance.PVector.angleBetween(g, v);
                                let resultV = new processingInstance.PVector(-vMag, 0);
                                resultV.rotate(gAngle - angle);
                                resultV.mult(-1);
                                this.velosity = resultV.get();
                                return "end";
                            }
                        },
                    },
                    "medium": {
                        setSize: function () {
                            this.size = 75;
                        },
                    },
                    "volley": {
                        setUp: function () {
                            let addMiss = new Array(0);

                            for (let i = 0; i < 5; i++) {
                                addMiss.push(new Missile(this.velosity, this.position, "XS", processingInstance.frameCount + i * 15));
                            }

                            return addMiss;
                        },
                    },
                    "triple": {
                        setUp: function () {
                            let addMiss = new Array(0);

                            let gap = 7, num = 3;
                            let side = gap * (num - 1) / 2;
                            for (let i = -side; i <= side; i += gap) {
                                addMiss.unshift(new Missile(processingInstance.PVector.rotate(this.velosity, i), this.position, "small"));

                                addMiss[0].advanceTurn = empty;
                            }

                            return addMiss;
                        },
                    },
                    "small": {
                        setSize: function () {
                            this.size = 50;
                        },
                    },
                    "rocket": {
                        onHit: function () {
                            let vel = new processingInstance.PVector(0, -20);
                            let pos = processingInstance.PVector.add(this.position, vel);

                            function addMissile(dir) {
                                missiles.push(new Missile(processingInstance.PVector.rotate(vel, dir), pos, "XS"));
                            }

                            function addMissiles(mult) {
                                addMissile(15 * mult);
                                addMissile(10 * mult);
                                addMissile(5 * mult);
                                addMissile(0 * mult);
                            }

                            addMissiles(-1);
                            addMissiles(1);

                            return true;
                        }
                    },
                    "over head": {
                        onHit: function () {
                            let x = Math.round(this.position.x);

                            for (let i = 0; i < 6; i++) {
                                let v = new processingInstance.PVector(0, 0.1);
                                let x2 = x - 60 + i * 20;
                                let p = new processingInstance.PVector(x2, 0);
                                let miss = new Missile(v, p, "XS");
                                missiles.push(miss);
                            }

                            return true;
                        },
                    },
                    "random rain": {
                        onHit: function () {
                            let x = Math.round(this.position.x);
                            for (let i = 0; i < 6; i++) {
                                let v = new processingInstance.PVector(0, 0.1);
                                let x2 = Math.round(x + processingInstance.random(-100, 100));
                                let p = new processingInstance.PVector(x2, 0);
                                let miss = new Missile(v, p, "XS");
                                missiles.push(miss);
                            }
                            return true;
                        },
                    },
                    "forest": {
                        setSize: function () {
                            this.size = 120;
                        },
                        getDivAmount: function () {
                            return Infinity;
                        },
                        onHit: function () {
                            let mx = Math.round(this.position.x);
                            for (let i = 0; i <= this.size; i += 7) {
                                let x = Math.round(mx + i - this.size / 2);
                                accessG(x).y -= 100;
                                accessG(x + 1).y -= 100;
                            }
                            return true;
                        },
                    },
                    "bounce small": {
                        advanceTurn: empty,
                        setUp: function () {
                            this.bounceTime = 50;
                        },
                        setSize: function () {
                            this.size = 10;
                        },
                        getDivAmount: function () {
                            return 5;
                        },
                        onHit: function (type) {
                            if (type === "edge") {
                                this.velosity.x *= -1;
                                this.exploded = false;
                                return "end";
                            } else if (this.frameC < this.bounceTime && type === "ground") {
                                this.exploded = false;
                                this.exploding = 0;
                                let x = this.position.x;
                                let v = this.velosity;
                                let g = new processingInstance.PVector(1, accessG(Math.round(x)).y - accessG(Math.round(x) - 1).y);
                                let vMag = v.mag();
                                let gAngle = g.heading();
                                let angle = processingInstance.PVector.angleBetween(g, v);
                                let resultV = new processingInstance.PVector(-vMag, 0);
                                resultV.rotate(gAngle - angle);
                                resultV.mult(-1);
                                this.velosity = resultV.get();
                                return "end";
                            }
                        },
                    },
                    "XS": {
                        advanceTurn: empty,
                        setSize: function () {
                            this.size = 25;
                        },
                        getDivAmount: function () {
                            return 5;
                        },
                    },
                    "XXS": {
                        advanceTurn: empty,
                        setSize: function () {
                            this.size = 10;
                        },
                        getDivAmount: function () {
                            return 5;
                        },
                    },
                    "slicer": {
                        getRank: function () {
                            return undefined;
                        },
                        advanceTurn: empty,
                        setUp: function () {
                            this.moves = 0;
                        },
                        getAddGravity: function () {
                            return false;
                        },
                        getDivAmount: function () {
                            return Infinity;
                        },
                        move: function () {
                            let prevPos = this.position.get();
                            this.position.add(processingInstance.PVector.div(this.velosity, 2));
                            this.moves += 0.5;

                            let startX = processingInstance.min(prevPos.x, this.position.x);
                            let endX = processingInstance.max(prevPos.x, this.position.x);

                            for (let i = Math.round(startX); i <= endX; i++) {
                                accessG(i).y = processingInstance.max(accessG(i).y, calcLinePosY(i, prevPos.x, prevPos.y, this.position.x, this.position.y));
                            }

                            if (this.moves >= 7) {
                                this.exploded = true;
                                this.setSize();
                                this.advanceTurn();
                            }
                        },
                    },
                    "collect box": {
                        getRank: function () {
                            return undefined;
                        },
                        setSize: function () {
                            this.size = 100;
                        },
                        draw: function () {
                            let diameter = this.exploding;
                            processingInstance.rotate(this.exploding / 1.1);

                            processingInstance.stroke(92);
                            processingInstance.strokeWeight(diameter * 0.02);
                            processingInstance.fill(120);
                            processingInstance.ellipse(0, 0, diameter, diameter);

                            processingInstance.stroke(0, 155, 255);
                            processingInstance.noFill();

                            for (let i = 0; i < 360; i += 30) {
                                let c1 = getCirclePoint(diameter / 4.2, (i + 96) * Math.PI / 180);
                                let c2 = getCirclePoint(diameter / 2.3, (i + 40) * Math.PI / 180);
                                let edge = getCirclePoint(diameter / 2, i * Math.PI / 180);

                                processingInstance.bezier(0, 0, c1.x, c1.y, c2.x, c2.y, edge.x, edge.y);
                            }
                        },
                        explode2: empty,
                        getDivAmount: function () {
                            return Infinity;
                        },
                        hitBox: function (i) {
                            boxes[i].collect(this.tank);
                        },
                    },
                    default: {
                        advanceTurn: advanceTurn,
                        draw: drawExplosion,
                        move: function (m) {
                            this.velosity.add(gravity);

                            let normVel = this.velosity.get();
                            normVel.normalize();
                            let velosityMag = this.velosity.mag();

                            for (let i = 0; i < velosityMag; i++) {
                                this.position.add(normVel);
                                let answer = this.check(m);
                                if (answer === "end") {
                                    break;
                                } else if (answer === true) {
                                    this.advanceTurn();
                                    break;
                                }
                            }
                        },
                        getDivAmount: function () {
                            return 3;
                        },
                        getAddGravity: function () {
                            return true;
                        },
                        explode1: function () {
                            this.exploding += 5;
                        },
                        calDist: function (other) {
                            let pos = this.position;

                            return processingInstance.dist(pos.x, pos.y, other.x, other.y);
                        },
                        hitBox: function (i) {
                            boxes.del(i, 1);
                        },
                        explode2: function () {
                            let minSize = processingInstance.min(-this.size / 2, 0);
                            let maxSize = processingInstance.min(this.size / 2, width);

                            for (let x = minSize; x < maxSize; x += 0.1) {
                                let y = this.calcCirclePos(this.position.x + x);
                                let xPos = Math.round(this.position.x) + Math.round(x);
                                if (xPos > 0 && xPos < width) {
                                    accessG(xPos)[1] = processingInstance.max(accessG(xPos)[1], y);
                                }
                            }
                        },
                        end: function () {
                            return this.exploding > this.size;
                        },
                    },
                };

                // Rank the missles
                let rank = 1;
                for (let type in missileTypes) {
                    if ("getRank" in missileTypes[type]) { continue; }
                    missileTypes[type].getRank = Object.constructor(
                        "return function() { return " + (rank++) + "; };")();
                }

                // Convert missileTypes from [type, actions] to [action, type]
                let actionTypes = Object.create(null);
                for (let type in missileTypes) {
                    for (let func in missileTypes[type]) {
                        if (!(func in actionTypes)) {
                            actionTypes[func] = {};
                        }
                        actionTypes[func][type] = missileTypes[type][func];
                    }
                }

                // Define some local functions
                function getMissProp(type, prop) {
                    if (prop in actionTypes) {
                        if (type in actionTypes[prop]) {
                            return actionTypes[prop][type];
                        } else if ("default" in actionTypes[prop]) {
                            return actionTypes[prop].default;
                        } else {
                            return empty;
                        }
                    }
                    return empty;
                }

                function hitTank(tank, x, y) {
                    let hitTank = false;

                    /* hit tank's hinge? */
                    let tHinge = tank.hinge;
                    hitTank ||= processingInstance.dist(tHinge.x, tHinge.y, x, y) < 5;


                    /* hit tank's body? */
                    let w = tank.width;
                    let h = tank.height;

                    let tankY = accessG(Math.round(tank.x))[1];

                    let tankBodyCornerss = [
                        { x: w / 2, y: h * -5 / 3 },
                        { x: w / 2, y: 0 },
                        { x: -w / 2, y: 0 },
                        { x: -w / 2, y: h * -5 / 3 },
                    ];

                    rotate2D(tankBodyCornerss, tank.angle);

                    tankBodyCornerss.forEach(function (corner) {
                        corner.x += tank.x;
                        corner.y += tankY;
                    });

                    hitTank ||= isInPolygon(x, y, tankBodyCornerss);

                    /* hit tank's cannon? */
                    let tankCannonCorners = [
                        { x: w * 2 / 3, y: -h / 4 },
                        { x: w * 2 / 3, y: h / 4 },
                        { x: 0, y: h / 4 },
                        { x: 0, y: -h / 4 },
                    ];

                    rotate2D(tankCannonCorners, tank.angle + tank.gunAngle);

                    let tankHinge = tank.hinge;
                    tankCannonCorners.forEach(function (corner) {
                        corner.x += tankHinge.x;
                        corner.y += tankHinge.y;
                    });

                    hitTank ||= isInPolygon(x, y, tankCannonCorners);

                    return hitTank && "tank";
                }

                // Constructor
                function Missile(velosity, startPos, type, start, tank) {
                    this.position = startPos.get();
                    this.velosity = velosity.get();
                    this.start = start || processingInstance.frameCount;
                    this.exploded = false;
                    this.started = false;
                    this.exploding = 0;
                    this.tank = tank;
                    this.type = type;
                    this.frameC = 0;
                    this.size = 0;

                    this.advanceTurn = getMissProp(this.type, "advanceTurn");
                    this.setSize = getMissProp(this.type, "setSize");
                    this.drawExp = getMissProp(this.type, "draw");
                    this.onHit = getMissProp(this.type, "onHit");
                    this.moveFunc = getMissProp(this.type, "move");
                    this.explode1 = getMissProp(this.type, "explode1");
                    this.calDist = getMissProp(this.type, "calDist");
                    this.hitBox = getMissProp(this.type, "hitBox");
                    this.explode2 = getMissProp(this.type, "explode2");
                    this.end = getMissProp(this.type, "end");
                    this.getDivAmount = getMissProp(this.type, "getDivAmount");

                    let result = getMissProp(this.type, "setUp").call(this);

                    if (result) {
                        advanceTurn(tank1, tank2);
                        return result;
                    }
                }

                // Static methods
                Object.assign(Missile, {
                    addGravityForShot: function (type) {
                        return getMissProp(type, "getAddGravity")();
                    },
                    findShot: function (array, findMin) {
                        // Smaller ranks are better
                        let peak = null;
                        let best = null;
                        for (let i = 0; i < array.length; i++) {
                            let curRank = getMissProp(array[i], "getRank")();
                            let div = getMissProp(array[i], "getDivAmount")();
                            let isNormal = curRank && div !== Infinity;
                            if (!peak || (isNormal || i + 1 >= array.length) &&
                                (findMin ? curRank > peak : curRank < peak)) {
                                peak = curRank;
                                best = array[i];
                            }
                        }
                        return best;
                    },
                });

                // Normal methods
                Object.assign(Missile.prototype, {
                    draw: function () {
                        if (!this.started) {
                            return;
                        }

                        processingInstance.pushMatrix();
                        processingInstance.translate(this.position.x, this.position.y);

                        if (this.exploding) {
                            this.drawExp();
                        } else {
                            processingInstance.rotate(this.velosity.heading());

                            processingInstance.fill(115, 115, 115);
                            processingInstance.noStroke();
                            processingInstance.rect(-10, -5 / 2, 15, 5, 10);
                        }
                        processingInstance.popMatrix();
                    },
                    calcCirclePos: function (x) {
                        x -= this.position.x;
                        let y = this.position.y;
                        let radius = this.exploding / 2;

                        return y + Math.sqrt(radius * radius - x * x);
                    },
                    move: function (m) {
                        this.frameC++;

                        if (this.start <= processingInstance.frameCount && !this.started) {
                            this.started = true;
                            this.frameC = 0;
                        }

                        if (this.started) {
                            if (this.exploded) {
                                return this.explode(m);
                            } else {
                                this.moveFunc(m);
                            }
                        }
                    },
                    checkHit: (function (hitTank) {
                        return function () {
                            let position = this.position;
                            let x = position.x;
                            let y = position.y;

                            // hit ground?
                            let hitGround = y >= accessG(Math.round(x))[1] && "ground";
                            // hit tank1?
                            let hitTank1 = hitTank(tank1, x, y);
                            // hit tank2?
                            let hitTank2 = hitTank(tank2, x, y);
                            // hit any?
                            return hitGround || hitTank1 || hitTank2;
                        };
                    })(hitTank),
                    check: function (m) {
                        let pos = this.position;

                        let hitEdge = pos.x !== (
                            pos.x = processingInstance.constrain(pos.x, 0, width));

                        let hitType = hitEdge && "edge" || this.checkHit();

                        let x = pos.x, y = pos.y;
                        for (let b = boxes.length; b-- > 0;) {
                            let bx = boxes[b].x;
                            let by = boxes[b].y;

                            if (x > bx - 5 && x < bx + 5 && y > by - 10 && y < by) {
                                this.hitBox(b);
                            }
                        }

                        if (!this.exploded && hitType) {
                            this.exploded = true;
                            this.setSize();
                            let a = this.onHit(hitType);
                            if (a === true) {
                                missiles.del(m, 1);
                                this.advanceTurn(tank1, tank2);
                                checkTie(tank1, tank2);
                                return "end";
                            } else if (a === "end") {
                                return "end";
                            }
                            return this.exploded;
                        }
                    },
                    explode: function (m) {
                        let x = this.position.x, y = this.position.y;

                        let maxDist1 = this.exploding / 2 + tank1.width / 2;
                        let maxDist2 = this.exploding / 2 + tank2.width / 2;

                        this.explode1();
                        let div = this.getDivAmount();
                        let d1 = this.calDist(tank1.hinge);
                        let d2 = this.calDist(tank2.hinge);

                        if (d1 < maxDist1 && !gameEnd) {
                            tank1.life -= (maxDist1 - d1) / div;
                        }
                        if (d2 < maxDist2 && !gameEnd) {
                            tank2.life -= (maxDist2 - d2) / div;
                        }

                        for (let i = boxes.length; i-- > 0;) {
                            let curBox = boxes[i];
                            let maxDist = this.exploding / 2 + 6;

                            if (this.calDist(curBox) < maxDist) {
                                this.hitBox(i);
                            }
                        }

                        this.explode2();

                        if (this.end()) {
                            checkTie(tank1, tank2);

                            missiles.del(m, 1);
                            return true;
                        }
                    },
                    toString: function () {
                        let strProps = ["type", "size", "position", "velosity"];
                        let propString = "";
                        for (let i = 0; i < strProps.length; i++) {
                            let comma = i > 0 ? "," : "", prop = strProps[i];
                            propString += comma + " " + prop + ": " + this[prop];
                        }
                        return "Missile {" + propString + " }";
                    },
                });

                return Missile;
            })();


            /** Tank constructor **/
            const Tank = (function () {
                // Some starting properties to put directly on new tanks
                let values = {
                    width: 40,
                    height: 10,
                    topFuel: 150,
                    scrollBarWidth: 15,
                    _menuOffSet: 0,
                    menuButtonSize: 34,
                    menuButtonSpace: 5,
                    menuSize: 225,
                    menuButtonOff: 15,
                    menuButtonWidth: 200,
                    menuButtonTextSize: 22,
                    numDots: 6,
                    displayMenu: false,
                    powerConPos: 100,
                    driveConPos: 0,
                    dragging: null,
                    _power: 100 / 3,
                    life: 500,
                };

                // Constructor
                function Tank(config) {
                    Object.assign(this, values);

                    this.side = config.side;
                    this.x = this.side === 1 ? left : right;
                    this.x += processingInstance.random(-tankStartRange, tankStartRange);
                    this.buttonJump = this.menuButtonSize + this.menuButtonSpace;
                    this.cannonLength = this.width * 2 / 3;
                    this.gunAngle = config.gunAngle;
                    this.num = config.num;
                    this.shots = ["big", "medium", "small", "over head", "volley", "super-volley", "bounce volley", "random rain", "top burn", "bounce", "line drive", "slicer", "forest", "rocket", "triple", "collect box"];
                    this.fuel = this.topFuel;
                    this.curShot = this.shots[0];
                    this.angleConPos = new processingInstance.PVector(50, 0);
                    this.angleConPos.rotate(this.gunAngle);
                    this.otherWrapper = config.otherWrapper;
                    this.playAI = config.playAI || false;
                    this.goForTank = false;
                }

                // Getters and setters
                Object.defineProperties(Tank.prototype, {
                    gunAngle: {
                        get: function () {
                            return this._gunAngle;
                        },
                        set: function (angle) {
                            this._gunAngle = angle < 0 ?
                                angle > -Math.PI ? angle : -Math.PI :
                                angle > (Math.PI / 2) ? Math.PI : 0;
                        }
                    },
                    power: {
                        get: function () {
                            return this._power;
                        },
                        set: function (power) {
                            this._power = processingInstance.constrain(power, 10, 100 / 3);
                        }
                    },
                    menuOff: {
                        get: function () {
                            return this._menuOffSet;
                        },
                        set: function (amount) {
                            this._menuOffSet = constrain2(amount, 0,
                                this.shots.length * this.buttonJump +
                                this.menuButtonSpace - height);
                        }
                    },
                    angle: {
                        get: function () {
                            return (-Math.atan2(this.width,
                                calcAvPixelHeight(this.x + this.width / 2) -
                                calcAvPixelHeight(this.x - this.width / 2)
                            ) + Math.PI / 2) % (Math.PI * 2);
                        }
                    },
                    hinge: {
                        get: function () {
                            // the tanks height
                            let tankHeight = new processingInstance.PVector(0, this.height * -5 / 3);
                            tankHeight.rotate(this.angle);

                            // the cannons hinge
                            let cannonHinge = new processingInstance.PVector(this.x, this.y);
                            cannonHinge.add(tankHeight);

                            return cannonHinge;
                        }
                    },
                    cannonTip: {
                        get: function () {
                            // the tanks gun
                            let gun = new processingInstance.PVector(this.cannonLength, 0);
                            gun.rotate(this.angle + this.gunAngle);

                            // add the hinge to get the tip of the gun
                            let cannonTip = processingInstance.PVector.add(this.hinge, gun);

                            return cannonTip;
                        }
                    },
                    heightOfShots: {
                        get: function () {
                            return this.buttonJump * this.shots.length +
                                this.menuButtonSpace;
                        }
                    },
                    y: {
                        get: function () {
                            return calcAvPixelHeight(this.x);
                        }
                    },
                });

                // Normal methods
                Object.assign(Tank.prototype, {
                    calcArc: function (numDots, addGravity) {
                        let angle = this.angle + this.gunAngle;

                        let shotArc = new processingInstance.PVector(this.power, 0);
                        shotArc.rotate(angle);

                        let dot = this.cannonTip;

                        let dots = [];

                        for (let i = 0; i < numDots; i++) {
                            if (addGravity) {
                                shotArc.add(gravity);
                            }
                            dot.add(shotArc);

                            dots.push(dot.get());
                        }

                        return dots;
                    },
                    drawArc: function () {
                        let numDots = this.shots.length === 0 ? 1 : this.numDots;

                        processingInstance.stroke(255, 255, 255);
                        processingInstance.strokeWeight(4);

                        let addGravity = Missile.addGravityForShot(this.curShot);

                        let dots = this.calcArc(numDots, addGravity);

                        dots.forEach(function (dot) {
                            processingInstance.point(dot.x, dot.y);
                        });
                    },
                    dropBox: function () {
                        boxes.push(new Box(this.x));
                    },
                    fireMissile: function () {
                        if (this.shots.length === 0) {
                            return;
                        }

                        if (!this.shots.includes(this.curShot)) {
                            this.curShot = this.shots[0];
                        }

                        let v = new processingInstance.PVector(this.power, 0);
                        v.rotate(this.angle + this.gunAngle);

                        missiles = missiles.concat(new Missile(v,
                            this.cannonTip, this.curShot, null, this));

                        this.shots.del(this.shots.indexOf(this.curShot), 1);
                        this.curShot = this.shots[0] || "";
                    },
                    dropMissiles: function () {
                        let pos = new processingInstance.PVector(this.x, accessG(Math.round(this.x))[1]);
                        let blank = new processingInstance.PVector();

                        this.shots.push("rocket");

                        missiles = missiles.concat(
                            this.shots.flatMap(function (shot) {
                                return new Missile(blank, pos, shot, null, this);
                            })
                        );

                        this.shots.length = 0;
                    },
                    draw: function () {
                        let y = this.y;
                        let w = this.width;
                        let h = this.height;
                        let h2 = this.height * 2 / 3;

                        this.color = this.num === 1 ?
                            processingInstance.color(0, 0, 255) : processingInstance.color(255, 0, 0);

                        processingInstance.noStroke();
                        processingInstance.fill(this.color);
                        if (y + screenShift > height) {
                            processingInstance.rect(this.x - w / 2, -screenShift, w, 6);
                        }

                        processingInstance.pushMatrix();
                        processingInstance.translate(this.x, y);
                        processingInstance.rotate(this.angle);

                        processingInstance.fill(this.color);
                        processingInstance.noStroke();

                        let crumples = [5, 11, 6, 15, 7, 10, 5, 9,
                            11, 5, 6, 7, 10, 5];

                        if (this.life <= 0) {
                            processingInstance.beginShape();
                            processingInstance.vertex(-w / 2, 0);

                            for (let i = 0; i < w; i++) {
                                processingInstance.vertex(-w / 2 + i * 3, -crumples[i]);
                            }

                            processingInstance.vertex(w / 2, 0);
                            processingInstance.endShape(processingInstance.CLOSE);
                        } else {
                            processingInstance.pushMatrix();
                            processingInstance.translate(0, -h2 - h);
                            processingInstance.rotate(this.gunAngle);
                            processingInstance.rect(0, -h / 4, w * 2 / 3, h / 2);
                            processingInstance.ellipse(0, 0, 10, 10);
                            processingInstance.popMatrix();

                            processingInstance.rect(-w / 2, -h2, w, -h);
                            w = w * (3 / 4);

                            processingInstance.stroke(120, 120, 120);
                            processingInstance.strokeWeight(9);
                            processingInstance.line(-w / 2, -h2 / 2, w / 2, -h2 / 2);

                            processingInstance.stroke(92, 92, 92);
                            processingInstance.strokeWeight(3);
                            processingInstance.line(-w / 2, -h2 / 2, w / 2, -h2 / 2);
                        }
                        processingInstance.popMatrix();
                        processingInstance.stroke(0, 255, 0);
                    },
                    drawLife: function () {
                        this.life = Math.max(this.life, 0);

                        processingInstance.noStroke();
                        processingInstance.fill(this.life / 2);
                        processingInstance.stroke(this.color);
                        processingInstance.strokeWeight(this.side === turn ? 4 : 2);

                        if (this.side === 1) {
                            processingInstance.rect(10, 10, 250, 20);
                            processingInstance.noStroke();
                            processingInstance.rect(10, 10, 250, 20);
                            processingInstance.fill(0, 255, 77);
                            processingInstance.rect(10, 10, this.life / 2, 20);
                        } else if (this.side === 2) {
                            processingInstance.rect(width - 10, 10, -250, 20);
                            processingInstance.noStroke();
                            processingInstance.rect(width - 10, 10, -250, 20);
                            processingInstance.fill(0, 255, 77);
                            processingInstance.rect(width - 10, 10, -this.life / 2, 20);
                        }
                    },
                    refill: function () {
                        this.fuel = this.topFuel;
                    },
                    getMoved: function (per, x, fuel) {
                        if (arguments.length <= 1) {
                            x = this.x;
                            fuel = this.fuel;
                        }
                        per = fuel > 0 ? processingInstance.constrain(per, -1, 1) : 0;
                        let pX = x;
                        let pY = calcAvPixelHeight(pX);
                        let halfW = this.width / 3;
                        let newX = processingInstance.constrain(x + per, halfW, 600 - halfW);
                        let tY = calcAvPixelHeight(newX);
                        let d = processingInstance.dist(newX, tY, pX, processingInstance.max(tY, pY));
                        let newFuel = processingInstance.max(fuel - d, 0);
                        return { x: newX, fuel: newFuel };
                    },
                    move: function (per) {
                        let result = this.getMoved(per);
                        this.x = result.x;
                        this.fuel = result.fuel;

                        if (this.shots.length === 0 && this.fuel <= 0) {
                            advanceTurn();
                        }
                    },
                    getDistTo: function (targ) {
                        let dir, targX, thisWidth = this.width;
                        let start = this.x;
                        let result = this.getMoved(0);
                        let lastX = null;
                        let canStop = function (x) {
                            return isBetween(targX, start, x);
                        };
                        switch (typeof targ) {
                            case "number":
                                dir = targ < this.x;
                                targX = targ;
                                break;
                            case "object":
                                if (targ.inRange) {
                                    canStop = function (x) {
                                        return targ.inRange(x, thisWidth);
                                    };
                                }
                                dir = targ.x < this.x;
                                targX = targ.x;
                                break;
                            default:
                            case "boolean":
                                dir = targ ? 1 : -1;
                                targX = undefined;
                                break;
                        }
                        while (!canStop(result.x) && result.x !== lastX) {
                            if (result.fuel <= 0) {
                                result.outOfFuel = true;
                                return result;
                            }
                            lastX = result.x;
                            result = this.getMoved(dir, result.x, result.fuel);
                        }
                        return result;
                    },
                    getFireAngleToHit: function (targ) {
                        // Formula from https: //en.wikipedia.org/wiki/Projectile_motion#Angle_%CE%B8_required_to_hit_coordinate_(x,_y)
                        // Also see https: //www.khanacademy.org/computer-programming/gun-targeting-processingInstance.point-with-gravity/5819054493450240
                        let launchPoint = this.cannonTip;
                        let x = -Math.abs(launchPoint.x - targ.x);
                        let y = launchPoint.y - targ.y;
                        if (x === 0 && y === 0) { return -Math.PI / 2; }
                        let v = this.power, g = gravity.y;
                        let angle = Math.atan((v * v +
                            Math.sqrt(v * v * v * v - g * (g * x * x + 2 * y * v * v))) / (g * x));

                        return this.x > targ.x ? -angle + Math.PI : angle;
                    },
                    aimAtTarget: function (targ) {
                        let inRange;
                        for (let i = 0; i < 20; i++) {
                            let angle = this.getFireAngleToHit(targ);
                            let adjusted = (angle - this.angle) % (Math.PI * 2);
                            adjusted = angle - this.angle;
                            inRange = !Number.isNaN(angle);
                            this._gunAngle = inRange ? adjusted : this.x > targ.x ? -Math.PI : 0;
                        }
                        return inRange;
                    },
                    getClosestBox: function () {
                        let closest = null;
                        let closestDist = -Infinity;
                        for (let i = 0; i < boxes.length; i++) {
                            let boxDist = this.getDistTo(boxes[i]);
                            if (!closest || boxDist.fuel > closestDist.fuel) {
                                closest = boxes[i];
                                closestDist = boxDist;
                            }
                        }
                        return { closest: closest, dist: closestDist };
                    },
                    moveAI: function () {
                        let doAction = true;
                        for (let i = 0; i < boxes.length; i++) {
                            if (!boxes[i].onGround) {
                                doAction = false;
                                break;
                            }
                        }

                        let other = this.otherWrapper.value;
                        let driveTarg = boxes[0] || other;
                        let goForTank = this.goForTank;
                        this.goForTank = false;
                        if (boxes.length > 0 && !goForTank) {
                            if (!doAction) { return; }
                            let value = this.getClosestBox();
                            let closest = value.closest;
                            let closestDist = value.dist;
                            if (!closestDist.outOfFuel || this.fuel > 0) {
                                this.move(closest.x > this.x ? 1 : -1);
                                if (closest.inRange(this.x, this.width) && !closest.type.includes("life")) {
                                    this.goForTank = true;
                                }
                            } else if (!Box.prototype.types.includes(Missile.findShot(this.shots))) {
                                let targetInRange = this.aimAtTarget(closest);
                                if (!doAction) { return; }
                                if (targetInRange) {
                                    let index = this.shots.indexOf("collect box");
                                    if (index > -1) {
                                        this.curShot = this.shots[index];
                                    } else {
                                        this.curShot = Missile.findShot(this.shots, true);
                                    }
                                    this.fireMissile();
                                } else if (this.fuel > 0) {
                                    this.move(closest.x > this.x ? 1 : -1);
                                } else {
                                    this.goForTank = true;
                                }
                            } else {
                                this.goForTank = true;
                            }
                        } else if (this.shots.length > 0) {
                            let targetInRange = this.aimAtTarget(other.hinge);
                            if (!doAction) { return; }
                            let start = Math.ceil(this.getDistTo(false).x);
                            let end = Math.floor(this.getDistTo(true).x);
                            let bestPos = null, best = Infinity;
                            let tester = Object.create(this);
                            for (let i = start; i <= end; i++) {
                                tester.x = i;
                                let inRange = tester.aimAtTarget(other.hinge);
                                if (accessG(i)[1] < best && inRange) {
                                    bestPos = i;
                                    best = accessG(i)[1];
                                }
                            }
                            let diff = Math.round(bestPos) - Math.round(this.x);
                            if (this.fuel > 0 && Math.abs(diff) >= 0.5) {
                                this.move(processingInstance.constrain(diff, -1, 1));
                            } else if (targetInRange) {
                                this.curShot = Missile.findShot(this.shots);
                                this.fireMissile();
                            } else {
                                this.curShot = Missile.findShot(this.shots, true);
                                this.fireMissile();
                            }
                        } else {
                            this.move(Math.random() * width > this.x ? 1 : -1);
                        }
                    },
                    drawControls: function () {
                        if (this.playAI) { return; }

                        function getShadedFill(stat, type) {
                            return processingInstance.color(0, 0, 0, stat === type ? 190 : 100);
                        }

                        processingInstance.stroke(140, 140, 140, 200);
                        /* drive control processingInstance.line */
                        processingInstance.strokeWeight(30);
                        processingInstance.line(50, 420, 150, 420);
                        /* power control processingInstance.line */
                        processingInstance.strokeWeight(20);
                        processingInstance.line(130, 460, 200, 460);
                        /* cannon control processingInstance.line */
                        processingInstance.noStroke();
                        processingInstance.fill(140, 140, 140, 200);
                        processingInstance.ellipse(500, 420, 130, 130);

                        /* fuel bar */
                        let fuelPos = this.fuel / (this.topFuel / 100);
                        processingInstance.fill(199, 199, 199, 200);
                        processingInstance.rect(50 + fuelPos, 380, 100 - fuelPos, 17);
                        processingInstance.fill(0, 171, 3, 200);
                        processingInstance.rect(50, 380, fuelPos, 17);

                        let shade = 0;
                        /* words for "no more shots" */
                        if (!this.shots.length) {
                            shade = 100;

                            processingInstance.fill(0, 0, 0);
                            processingInstance.textAlign(processingInstance.CENTER, processingInstance.CENTER);
                            processingInstance.textSize(15);
                            processingInstance.text("NO MORE SHOTS!", 283, 435);
                        }

                        /* fire button */
                        processingInstance.fill(255, 140, 0, 255 - shade);
                        processingInstance.rect(215, 445, 40, 30, 10);
                        processingInstance.fill(0);
                        processingInstance.textAlign(processingInstance.CENTER, processingInstance.CENTER);
                        processingInstance.textSize(20);
                        processingInstance.text("fire", 235, 460);

                        /* shot select button */
                        let message = "shot type: " + this.curShot;
                        processingInstance.fill(247, 255, 0, 255 - shade);
                        processingInstance.textSize(17);
                        processingInstance.rect(260, 445, processingInstance.textWidth(message) + 14, 30, 10);
                        processingInstance.fill(0);
                        processingInstance.textAlign(processingInstance.LEFT, processingInstance.CENTER);
                        processingInstance.text(message, 267, 460);

                        /* words for "no fuel" */
                        if (this.fuel === 0) {
                            processingInstance.fill(232, 217, 0);
                            processingInstance.textAlign(processingInstance.CENTER, processingInstance.CENTER);
                            processingInstance.textSize(20);
                            processingInstance.text("NO FUEL", 100, 370);
                        }

                        // drive control circle */
                        processingInstance.fill(getShadedFill(this.dragging, "driveCon"));
                        processingInstance.ellipse(100 + this.driveConPos, 420, 25, 25);

                        /* cannon control circle */
                        processingInstance.fill(getShadedFill(this.dragging, "angleCon"));
                        processingInstance.ellipse(500 + this.angleConPos.x, 420 + this.angleConPos.y, 30, 30);
                        /* power control circle */
                        processingInstance.fill(getShadedFill(this.dragging, "powerCon"));
                        processingInstance.ellipse(130 + this.powerConPos - 30, 460, 16, 16);

                        /* shot menu */
                        if (this.displayMenu) {
                            /* variables */
                            let space = this.menuButtonSpace;
                            let bHeight = this.menuButtonSize;
                            let off = this.menuOff;
                            let barWidth = this.scrollBarWidth;
                            let bWidth = this.menuButtonWidth;
                            let shotsHeight = this.heightOfShots;
                            if (shotsHeight > height) {
                                bWidth -= barWidth;
                            }
                            let relX = this.menuButtonOff;
                            let bJump = this.buttonJump;
                            let menuX = width - this.menuSize;

                            /* menu background */
                            processingInstance.fill(0);
                            processingInstance.rect(menuX + 5, 0, this.menuSize, height);
                            processingInstance.fill(168);
                            processingInstance.rect(menuX, 0, 10, height);

                            /* shots */
                            processingInstance.textSize(this.menuButtonTextSize);
                            processingInstance.textAlign(processingInstance.LEFT, processingInstance.CENTER);

                            for (let i = 0; i < this.shots.length; i++) {
                                let y = space + i * bJump - off;

                                processingInstance.fill(171, 171, 171);
                                processingInstance.rect(menuX + relX, y, bWidth, bHeight, 20);
                                processingInstance.fill(0);
                                processingInstance.text(this.shots[i], menuX + 25, bHeight / 2 + y);
                            }

                            /* scroll bar */
                            if (shotsHeight > height) {
                                processingInstance.fill(220);
                                processingInstance.rect(width, 0, -barWidth, height);
                                processingInstance.fill(170);
                                let fraction = height / shotsHeight;

                                processingInstance.rect(width, off * fraction, -barWidth, height * fraction);
                            }
                        }
                    },
                    moveControls: function () {
                        if (missiles.length) {
                            return;
                        }
                        if (this.playAI) {
                            this.moveAI();
                        } else switch (this.dragging) {
                            case "driveCon":
                                this.driveConPos = processingInstance.constrain(processingInstance.mouseX - 100, -50, 50);
                                this.move(this.driveConPos / 50);
                                break;
                            case "angleCon":
                                this.angleConPos.x = processingInstance.mouseX - 500;
                                this.angleConPos.y = processingInstance.mouseY - (height - 80);
                                this.angleConPos.normalize();
                                this.angleConPos.mult(50);
                                this.gunAngle = this.angleConPos.heading();
                                break;
                            case "powerCon":
                                this.power = (processingInstance.mouseX - 100) / 3;
                                this.powerConPos = this.power * 3;
                                break;
                            case "menu":
                                this.menuOff += pmouseY - processingInstance.mouseY;
                                break;
                            case "menuBar":
                                let fraction = this.heightOfShots / height;
                                this.menuOff += (processingInstance.mouseY - processingInstance.pmouseY) * fraction;
                                break;
                        }
                    },
                    click: function (x, y) {
                        if (this.playAI) { return; }
                        let rectLen = processingInstance.textWidth(
                            "shot type: " + this.curShot) + 14;

                        if (this.displayMenu) {
                            let menuX = width - this.menuSize;

                            if (x < menuX) {
                                this.displayMenu = false;
                            }

                            let buttonX = menuX + this.menuButtonOff;
                            let buttonW = this.menuButtonWidth;
                            if (this.heightOfShots > height) {
                                buttonW -= this.scrollBarWidth;
                            }

                            if (processingInstance.mouseX > buttonX && x < buttonX + buttonW) {
                                let space = this.menuButtonSpace;
                                let bHeight = this.menuButtonSize;
                                let bJump = space + bHeight;
                                let mY = processingInstance.mouseY - space + this.menuOff;

                                let numShots = this.shots.length;
                                let isIn = mY % bJump <= bHeight && mY > 0;
                                let shotInd = Math.floor(mY / bJump);

                                let clicked = isIn &&
                                    shotInd < numShots && shotInd;

                                if (clicked !== false) {
                                    this.curShot = this.shots[clicked];

                                    this.displayMenu = false;
                                }
                            }
                        } else if (x > 215 && y > height - 55 &&
                            x < 215 + 40 && y < height - 55 + 30) {

                            this.fireMissile();
                        } else if (x > 260 && y > height - 55 &&
                            x < 260 + rectLen && y < height - 55 + 30) {

                            this.displayMenu = true;
                        }
                    },
                    mousePressed: function (x, y) {
                        if (this.playAI) { return; }
                        if (this.displayMenu) {
                            if (this.buttonJump * this.shots.length > height) {
                                if (processingInstance.mouseX > width - this.scrollBarWidth) {
                                    let fraction = height / this.heightOfShots;
                                    let barY = this.menuOff * fraction;
                                    let barHeight = height * fraction;

                                    if (y > barY && y < barY + barHeight) {
                                        this.dragging = "menuBar";
                                    }
                                } else if (x > width - this.menuSize) {
                                    this.dragging = "menu";
                                }
                            }
                        } else if (processingInstance.dist(x, y, 100 + this.driveConPos, height - 80) < 25 / 2) {
                            this.dragging = "driveCon";
                        } else if (processingInstance.dist(x, y, 500 + this.angleConPos.x, height - 80 + this.angleConPos.y) < 15) {
                            this.dragging = "angleCon";
                        } else if (processingInstance.dist(x, y, 100 + this.powerConPos, height - 40) < 8) {
                            this.dragging = "powerCon";
                        }
                    },
                    mouseReleased: function () {
                        if (this.playAI) { return; }
                        this.dragging = null;
                        this.driveConPos = 0;
                    },
                    mouseDragged: function () {
                        return this.dragging || this.displayMenu;
                    },
                    scroll: function (amount, x) {
                        if (this.playAI) { return; }
                        if (this.displayMenu) {
                            if (x > width - this.menuSize) {
                                this.menuOff -= amount;
                            }
                            return true;
                        }
                    },
                });

                return Tank;
            })();


            /** Tanks **/
            function defineTanks() {
                let tank1Wrapper = { value: null };
                let tank2Wrapper = { value: null };

                tank1 = new Tank({
                    side: 1, gunAngle: processingInstance.random(Math.PI, 0),
                    num: blueStart ? 1 : 2, otherWrapper: tank2Wrapper,
                    playAI: numPlayers <= (blueStart ? 0 : 1)
                });
                tank2 = new Tank({
                    side: 2, gunAngle: processingInstance.random(Math.PI, 0),
                    num: blueStart ? 2 : 1, otherWrapper: tank1Wrapper,
                    playAI: numPlayers <= (blueStart ? 1 : 0)
                });

                tank1Wrapper.value = tank1;
                tank2Wrapper.value = tank2;
            }
            defineTanks();


            /** Less global functions **/
            function drawGround() {
                processingInstance.noStroke();
                processingInstance.fill(153, 69, 0);
                processingInstance.beginShape();
                processingInstance.vertex(0, height - screenShift);

                ground.forEach(function (g, i) {
                    processingInstance.vertex(g.x, g.y - screenShift);
                });

                processingInstance.vertex(width, height - screenShift);
                processingInstance.endShape();
            }

            function drawScreen() {
                // Title
                processingInstance.textSize(90);
                processingInstance.textAlign(processingInstance.CENTER, processingInstance.CENTER);
                processingInstance.fill(255, 255, 255);
                processingInstance.text("TANK GAME", 300, 60);

                // Winner
                processingInstance.noStroke();
                processingInstance.fill(0, 237, 237); // Light blue
                processingInstance.rect(50, 200, 250, 250); // Light blue background

                processingInstance.fill(105, 47, 0); // Sign processingInstance.color
                processingInstance.rect(175, 320, 110, 70, 6); // Sign body
                processingInstance.rect(225, 370, 10, 30); // Sign post

                processingInstance.fill(255, 255, 255);
                processingInstance.textSize(15);
                processingInstance.text("Blue\n" + tank1Score, 206, 355); // Blue score processingInstance.text
                processingInstance.text("Red\n" + tank2Score, 254, 355); // Red score processingInstance.text


                let x = 100;
                let y = 230;

                processingInstance.stroke(0);
                processingInstance.strokeWeight(3);
                processingInstance.line(98, 251, 98, 400);

                // Retrieve flag processingInstance.image
                let flag = flagImgs[won];
                if (!flag) { // If we don't have this processingInstance.image, create it
                    flag = processingInstance.createGraphics(90, 50, processingInstance.JAVA2D); // New processingInstance.image
                    if (won.toLowerCase().includes("blue")) { //  Backgrounds
                        flag.background(0, 106, 255); // Blue background
                    } else if (won.toLowerCase().includes("red")) {
                        flag.background(255, 0, 0); // Red background
                    } else {
                        flag.background(0, 245, 0); // Default background
                    }
                    flag.fill(0, 0, 0); // Text processingInstance.color
                    flag.textSize(15); // Text size
                    flag.textAlign(processingInstance.CENTER, processingInstance.CENTER); // Center processingInstance.text
                    flag.text(won, 45, 25); // Draw processingInstance.text
                    // Add the wiggles to the flag
                    flag = skewImage(flag, function (x) {
                        return 6 * (1 - Math.sin(x * Math.PI / 42));
                    });
                    flagImgs[won] = flag; // Save the flag
                }
                processingInstance.imageMode(processingInstance.CENTER);
                processingInstance.image(flag, x + 45, y + 45); // Draw the flag

                processingInstance.noStroke();
                processingInstance.fill(153, 69, 0);
                processingInstance.rect(50, 400, 250, 50); // Dirt

                // Buttons
                processingInstance.stroke(64, 64, 64);
                processingInstance.strokeWeight(2);
                processingInstance.fill(143, 143, 143);
                processingInstance.rect(340, 200, 225, gameEnd ? 60 : 80, 15);

                // Button processingInstance.text
                processingInstance.fill(0, 0, 0);
                processingInstance.textSize(35);
                if (gameEnd) { processingInstance.text("Restart", 340 + 225 / 2, 230); }
                else { processingInstance.text("Start game", 340 + 225 / 2, 240); }

                // Game playback
                if (gameEnd) {
                    screenNum = screenNum + 0.5 || 0;
                    screenNum %= screens.length;
                    processingInstance.image(screens[Math.floor(screenNum)], imageX, imageY,
                        width / imageScale, height / imageScale);
                }
            }

            function checkButtons() {
                let x = imageX, y = imageY;
                let w = width / imageScale / 2, h = height / imageScale / 2;

                if (processingInstance.mouseX > x - w && processingInstance.mouseX < x + w && processingInstance.mouseY > y - h && processingInstance.mouseY < y + h) {
                    if (processingInstance.mouseButton === processingInstance.RIGHT) {
                        if (imageScale === defaultImageScale) {
                            imageX = width / 2; imageY = height / 2;
                            imageScale = 1;
                        } else {
                            imageX = defaultImageX; imageY = defaultImageY;
                            imageScale = defaultImageScale;
                        }
                    } else {
                        screens = screens === gameScreens ?
                            lastShotScreens : gameScreens;
                        screenNum = 0;
                    }
                }
                else if (processingInstance.mouseX > 340 && processingInstance.mouseY > 200 && processingInstance.mouseX < 340 + 225 && processingInstance.mouseY < 200 + (gameEnd ? 60 : 80)) {
                    if (gameEnd) {
                        restart();
                    } else {
                        gameStarted = true;
                    }
                }
            }

            function restart() {
                gameEnd = false;
                gameStarting = 60;
                gameEnding = 60;
                screenShift = 0;
                missiles.length = 0;
                boxes.length = 0;
                gameScreens.length = 0;
                lastShotScreens.length = 0;
                screens = gameScreens;
                blueStart = !blueStart;
                turn = 1;

                defineTanks();

                chooseGround();
            }

            function recordScreenAndDrawLives() {
                processingInstance.stroke(0, 200, 200);
                processingInstance.strokeWeight(2);
                processingInstance.line(0, 0, width, 0);

                processingInstance.resetMatrix();
                tank1.drawLife();
                tank2.drawLife();

                if (numMissiles !== 0) {
                    let screen = processingInstance.get();
                    gameScreens.push(screen);
                    lastShotScreens.push(screen);
                } else if (!gameEnd) {
                    lastShotScreens.length = 0;
                }
            }


            /** User interface **/
            processingInstance.mousePressed = function () {
                cMouseX = processingInstance.mouseX;
                cMouseY = processingInstance.mouseY;
                if (!gameStarted || gameEnd) {
                    return;
                }
                shouldDrag = true;
                let thisTank = turn === 1 ? tank1 : tank2;
                thisTank.mousePressed(processingInstance.mouseX, processingInstance.mouseY);
            };

            processingInstance.mouseOut = processingInstance.mouseReleased = function () {
                if (!gameStarted || gameEnd) {
                    return;
                }
                shouldDrag = false;
                let thisTank = turn === 1 ? tank1 : tank2;
                thisTank.mouseReleased();
            };

            processingInstance.mouseClicked = function () {
                if (processingInstance.dist(processingInstance.mouseX, processingInstance.mouseY, cMouseX, cMouseY) > 10) {
                    return;
                }
                if (!gameStarted) {
                    checkButtons();
                    return;
                } else if (gameEnd || missiles.length) {
                    return;
                }
                let thisTank = turn === 1 ? tank1 : tank2;
                thisTank.click(processingInstance.mouseX, processingInstance.mouseY);
            };

            processingInstance.mouseDragged = function () {
                if (!shouldDrag) { return; }
                if (!(tank1.mouseDragged() || tank2.mouseDragged() || !gameStarted)) {
                    screenShift += processingInstance.mouseY - processingInstance.pmouseY;
                }
            };

            processingInstance.mouseScrolled = function () {
                let thisTank = turn === 1 ? tank1 : tank2;
                if (!thisTank.scroll(processingInstance.mouseScroll * 100, processingInstance.mouseX)) {
                    screenShift += processingInstance.mouseScroll * 100;
                }
            };


            /** Game loop **/
            processingInstance.draw = function () {
                if (gameStarted) {
                    processingInstance.background(0, 237, 237);

                    processingInstance.translate(0, screenShift);

                    drawGround();

                    for (let i = missiles.length; i-- > 0;) {
                        missiles[i].draw();
                        missiles[i].move(i);
                    }

                    numMissiles = missiles.length;

                    tank2.draw();
                    tank1.draw();

                    for (let i = boxes.length; i-- > 0;) {
                        if (!boxes[i]) { continue; }
                        boxes[i].draw();
                        boxes[i].move();
                        boxes[i].check();
                    }

                    let t1 = blueStart ? tank1 : tank2;
                    let t2 = blueStart ? tank2 : tank1;
                    if (!gameEnd && numMissiles === 0) {
                        if (t2.life <= 0) {
                            t2.life = 0;

                            if (t1.life <= 0) {
                                won = "It's a tie!";
                                gameEnd = true;

                                t1.dropMissiles();
                                t2.dropMissiles();
                            } else {
                                won = "Blue tank\nwins!";
                                gameEnd = true;
                                tank1Score++;

                                t2.dropMissiles();
                            }
                        } else if (t1.life <= 0) {
                            t1.life = 0;
                            won = "Red tank\nwins!";
                            gameEnd = true;
                            tank2Score++;

                            t1.dropMissiles();
                        }
                    }

                    if (gameEnd) {
                        gameEnding--;

                        recordScreenAndDrawLives();

                        if (gameEnding <= 0) {
                            gameStarted = false;
                        }
                    } else if (missiles.length === 0 && !gameEnd) {
                        let curTank = turn === 1 ? tank1 : tank2;

                        curTank.drawArc();

                        recordScreenAndDrawLives();

                        curTank.drawControls();
                        curTank.moveControls();
                    } else {
                        recordScreenAndDrawLives();
                    }

                    checkTie(tank1, tank2);

                    pnumMissiles = numMissiles;
                } else {
                    processingInstance.background(0);
                    drawScreen();
                }

                pmouseX = processingInstance.mouseX;
                pmouseY = processingInstance.mouseY;
                // Some code to be uncommented when the code might not work
                /*
                processingInstance.pushMatrix();
                processingInstance.translate(30, 470);
                processingInstance.rotate(Math.PI / 2);
        
                processingInstance.stroke(255, 0, 0);
                processingInstance.strokeWeight(50);
                processingInstance.point(0, 0);
                processingInstance.fill(0, 0, 0);
                processingInstance.textSize(14);
                processingInstance.textAlign(processingInstance.CENTER, processingInstance.CENTER);
                processingInstance.text("BUGS!", 0, 0);
        
                processingInstance.popMatrix();
                //*/
            };

        };

        // More credit to pamela at the same program
        // Pass the function to ProcessingJS constructor
        let processingInstance = new Processing(canvas, programCode);
    </script>
</body>

</html>