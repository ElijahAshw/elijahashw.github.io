<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Conway's game of life</title>
        <style>
            body {
                background: #111111;
                color: #ccc;
            }

            * {
                box-sizing: border-box;
            }

            canvas {
                background: #efefef;
                cursor: pointer;
            }
            
            textarea {
                width: 620px;
                height: 51px;
                color: #000;
                font-family: monospace;
            }
            textarea::placeholder {
                color: #888;
                font-style: italic;
            }
            canvas, i {
                display: block;
            }
            #seperator {
                display: block;
                height: 50px;
            }
            .input-wrapper {
                display: inline;
                position: relative;
            }
            .input-wrapper > input + label {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translateX(-50%);
                white-space: nowrap;
            }
            button, select, input {
                border-radius: 4px;
                border: 1px solid black;
                cursor: pointer;
                background-color: #777;
            }
            select {
                background-color: #333;
                color: inherit;
            }
            button.underline::first-letter {
                text-decoration: underline;
            }
            button {
                margin-right: 2px;
                box-shadow: 1px 1px 0px #888;
            }
            button:active {
                box-shadow: 0px 0px 0px #888;
                transform: translate(1px, 1px);
            }
            #counter {
                display: inline;
                font-family: sans-serif;
            }
            #next {
                background: #aee;
            }
            #randomize {
                background: #e0f;
            }
            #clear {
                background: #ff0;
            }
            #start {
                background: #0cf600;
            }
            #stop {
                background: #ff511c;
            }
            #back {
                background: #00ffa6;
            }
            #part-button-wrapper {
                margin-left: 20px;
                margin-top: 9px;
                border-radius: 6px;
                border: solid 1.5px #555;
                padding: 1px 2px 3px 3px;
                display: inline-block;
                white-space: nowrap;
            }
            #part-button-wrapper button {
                background: #80bbff;
            }
            #source {
                margin-top: 20px;
            }
            #spacer {
                height: 70px;
                visibility: hidden;
            }
            :link {
                color: #5a5aff;
            }
            :visited {
                color: #a352ec;
            }
            :link:active, :visited:active {
                color: #ff090d;
            }
        </style>
    </head>
    <body>
    <canvas onclick="toggle(event, this)"></canvas>
    
    <button id="next" class="underline">Next</button>
    <button id="randomize" class="underline">Randomize</button>
    <button id="clear" class="underline">Clear</button>
    <button id="start" class="underline">Start</button>
    <div class="input-wrapper">
        <input id="speed" type="range" min="-100" max="100" value="0">
        <label for="speed" id="speed-counter">Speed</label>
    </div>
    <p id="counter"></p>
    <button id="back" class="underline">Back</button>
    <div id="part-button-wrapper">
        Library and part-screen tools:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <select id="pattern">
            <option value="#!$#!$#$$$">Glider</option>
            <option value="!!!$#%$%%!%%&#&$&%">LWSS</option>
            <option value="!#!%#&$!$&%&&#&&'$'%'&">MWSS</option>
            <option value="!#!%#&$!$&%!%&&&'#'&($(%(&">HWSS</option>
            <option value="!!#!###$%$$%%%">Eater1</option>
            <option value="'!&#(#'$%&&&'&(&)&!'$'*'¶'!(#(%()(+(¶(%)))%*)*&+'+(+&-'-(-%.).%/&/(/)/">Elijah's oscillator</option>
            <option value="!%!&#%#'$!$#$%$'%!%%%'%(&%'!'%'''((!(#(%(')%)'*%*&">Elijah's on-off</option>
            <option value="|I|K|L}I}J}L¤J¥D¥E¥I¥M¥N¥O¦D¦E¦H¦O§I§O¨J¨K¨M¨N±`±aµ`µaÀ]À^ÀdÀeÁ]Á^ÁdÁeÄhÅfÅgÅhÆeÇeÇf×pØoØqÙoÙqÚpÜkÜlÜtÜuÝjÝmÝsÝvÞkÞlÞtÞuàpáoáqâoâqãpëÁëÂìÁìÂïÄïÅðÄðÅòÁòÂóÁóÂü¦ü§ý§þ¤þ¥þ¦ÿ¤ĀËĀÌĀÍāÊāÍĂÊĂÍăÓăÔĄÊĄÔąÊąÎąÓĆËĆÍĆÓĆÔćÌĊÌĊÍċÌċÍ">Elijah's big oscillator</option>
            <option value="!'!)!*#'#(#*)!)#)))**!*#*)**¶&¶'-&-'<B<C<E<F=A=G>A>H>K>L?A?B?C?G?K?L@FQEQFRFSCSDSETCXZYYY[ZYZ[[Z^U^V^_^`^i_T_W_^_a_g_h_i`U`V`_```fafagbZcYc[dYd[eZgtguhthukwkxlwlxntnuotoutdudvcvewdxdydzd{c{e|d|~|¡|¢}d}}}¢~}~¢¡¨¡©¢}¢©£}£££¨¤~¤¢¤¨¤©¥¡¨¡¨¢©¡©¢">Elijah's p2520 gun</option>
            <option value="!J!K#J$H$J%H%I&¶&-&/&:&D&E'-'/':'D'E(-)*)+)-)/):);*+*-*/*:*;*H*I+#+$+++-+.+<+G+J¶$¶¶¶:¶;¶H¶I-$-&---.-/.%.'./.D/'/(/*/+/C/E:*:+:C:E;$;%;D<%=!=#=$>!>*?)?+@(@+A)A*A.A/B.B:C.D%D&E$E&ESETEUF$FSFfFgG#G$GTGfGgJ&J'J-J.JgK&K'K-K.KfKhLeLiM*M+MiN*N+OfOiPfPiQfQgQhRKRLS<S=S>S?SKSLT;TUTVTWU:U?UHUIUOUPUTUXV;V=V>VHVIVOVPVSVYVtW<WuXRXZXsXtXuYRYZZx[E[S[Y[w[y]D]F]H]J]K]T]X]x]y^E^F^H^I^K^U^V^W_q_r_x_y`q`r`yaxbnbobxbycncofqfrgqgr">Elijah's p3000 gun (Old record)</option>
            <option value="!J!K#J$H$J$p%H%I%n%o%p&¶&-&/&:&D&E&m'-'/':'D'E'e'f'm'n(-(e(g)*)+)-)/):);)f*+*-*/*:*;*H*I+#+$+++-+.+<+G+J¶$¶¶¶:¶;¶H¶I¶r¶s-$-&---.-/-j-k-r-s.%.'./.D.j.k/'/(/*/+/C/E:*:+:C:E:a:b;$;%;D;a;b<%=!=#=$=p=q>!>*>p>r?)?+?r@(@+@r@sA)A*A.A/B.B:C.D%D&E$E&ESETEUF$FSFfFgG#G$GTGfGgJ&J'J-J.JgK&K'K-K.KfKhLeLiM*M+MiN*N+OfOiPfPiQfQgQhRKRLS<S=S>S?SKSLT;TUTVTWU:U?UHUIUOUPUTUXV;V=V>VHVIVOVPVSVYVtW<WuXRXZXsXtXuYRYZZx[E[S[Y[w[y]D]F]H]J]K]T]X]x]y^E^F^H^I^K^U^V^W_q_r_x_y`q`r`yaxbnbobxbycncofqfrgqgr">Elijah's p6000 gun (Record?)</option>
            <option value="!J!K!h!k!l#J#h#i#j#k#m$H$J$m%H%I%f%g%h%i%j%k%l%n%o&¶&-&/&:&D&E&e&l&n&q'-'/':'D'E'e'f'i'j'l'p'q(-(i(j(l(m)*)+)-)/):);*+*-*/*:*;*H*I+#+$+++-+.+<+G+J¶$¶¶¶:¶;¶H¶I-$-&---.-/-`-a.%.'./.D.a.i.j/'/(/*/+/C/E/a/c/i/j:*:+:C:E:b:c;$;%;D<%=!=#=$>!>*?)?+@(@+A)A*A.A/AlAmB.B:BlC.CmCnCoD%D&DoE$E&ESETEUF$FSFfFgG#G$GTGfGgJ&J'J-J.JgK&K'K-K.KfKhLeLiM*M+MiN*N+OfOiPfPiQfQgQhRKRLS<S=S>S?SKSLT;TUTVTWU:U?UHUIUOUPUTUXV;V=V>VHVIVOVPVSVYVtW<WuXRXZXsXtXuYRYZZx[E[S[Y[w[y]D]F]H]J]K]T]X]x]y^E^F^H^I^K^U^V^W_q_r_x_y`q`r`yaxbnbobxbycncofqfrgqgr">Elijah's p9000 gun (Record?)</option>
            <option value="!<!=#<$=$Y$Z%&%<%=%Y%[&&&'&(&>&?&[&a&b')'<'='@'W'X'Y'Z']'^'a'd((()(=(?(Q(R(W(Z(](_(a(c(d)#)$)¶);)=)?)@)Q)Z)])_)a*$*+*-*;*<*S*[*]*_*a+$+&+++.+O+P+Q+R+S+`¶%¶&¶¶¶-¶O-R-S-T-U.R.U.Z.[/#/$/Z/[:$:M:N;#;M;P;R;S<#<$<O<P<R<S=&='>#>$>&>'?!?$@!@&@'@(@)A#A$A%A)A^A_B&B^C%C&C_C`CaDaFDFEFFGDGVGWHEHVHWKWLVLXMUMYNYPVPYQVQYRVRWRXUFUGUHVEVIWDWJWeXfYCYKYdYeYfZCZK]D]J^E^I_F_G_H`b`c`i`jabacajbic_c`cicjd_d`gbgchbhc">Elijah's p4080 gun (Record)</option>
            <option value="!<!=!Y!]!^#<#Y#Z#[#]#_$=$_%&%<%=%W%X%Y%Z%[%]%^%`%a&&&'&(&>&?&V&^&`&c')'<'='@'V'W'Z'['^'b'c((()(=(?(Z([(^(_)#)$)¶);)=)?)@*$*+*-*;*<+$+&+++.¶%¶&¶¶¶--Q-R.R.Z.[/#/$/R/T/Z/[:$:S:T;#<#<$=&='>#>$>&>'?!?$@!@&@'@(@)A#A$A%A)A^A_B&B^C%C&C_C`CaDaFDFEFFGDGVGWHEHVHWKWLVLXMUMYNYPVPYQVQYRVRWRXUFUGUHVEVIWDWJWeXfYCYKYdYeYfZCZK]D]J^E^I_F_G_H`b`c`i`jabacajbic_c`cicjd_d`gbgchbhc">Elijah's p6120 gun (Record)</option>
            <option value="!<!=!Y!]!^#<#Y#Z#[#]#_$=$_%&%<%=%W%X%Y%Z%[%]%^%`%a&&&'&(&>&?&V&^&`&c')'<'='@'V'W'Z'['^'b'c((()(=(?(Q(R(Z([(^(_)#)$)¶);)=)?)@)Q*$*+*-*;*<*S+$+&+++.+O+P+Q+R+S¶%¶&¶¶¶-¶C¶O-A-B-C-R-S-T-U.@.R.U.Z.[/#/$/@/A/Z/[:$:M:N;#;M;P;R;S<#<$<O<P<R<S=&='>#>$>&>'?!?$?L@!@&@'@(@)@J@K@LA#A$A%A)AIA^A_B&BIBJB^C%C&C_C`CaDaFDFEFFGDGVGWHEHVHWKWLVLXMUMYNYPVPYQVQYRVRWRXUFUGUHVEVIWDWJWeXfYCYKYdYeYfZCZK]D]J^E^I_F_G_H`b`c`i`jabacajbic_c`cicjd_d`gbgchbhc">Elijah's p7200 gun (Record)</option>
            <option value="!<!=!O#<#O#P#Q$=$R%&%<%=%Q%R&&&'&(&>&?')'<'='@((()(=(?)#)$)¶);)=)?)@*$*+*-*;*<*F*G*M*N+$+&+++.+F+G+M+N¶%¶&¶¶¶--J-K.J.K/#/$:$;#<#<$<V<b<c=&='=T=U=V=b=c>#>$>&>'>T>U>V?!?$?S?W?_?`?f?g@!@&@'@(@)@T@U@V@W@_@`@f@gA#A$A%A)ATAUAWB&C%C&HFHGHHIFJGQuQvRtRwR}R~SuSvSxS~TlTxT{T|T}UjUlUwUxUzVkVlVtVuVwVzWsWvWyW{W|W}XtXuY~Z|Z~[|[}_x_y`w`zawaybxd}eye{e|e}fyf{f|gYgZg[gegfgggxgyg{hYhZh[heh{h|iZifiyi{jZjwjyjzj{kZkvkwkxkylYl[ltlulvmcmdmimsmuncndninjnsoYo[ocodojokorospZpbpcqZqbqcrZrarcrnrosYsZs[sbsesfsntYtZt[t_t`tatetgtotptqu_uguqvgvh">Elijah's p5160 gun (Record)</option>
            <option value="!<!=#<$=$Y$Z%&%<%=%Y%[&&&'&(&>&?&[&a&b')'<'='@'W'X'Y'Z']'^'a'd((()(=(?(Q(R(W(Z(](_(a(c(d)#)$)¶);)=)?)@)Q)Z)])_)a*$*+*-*;*<*S*[*]*_*a+$+&+++.+O+P+Q+R+S+`¶%¶&¶¶¶-¶C¶O-A-B-C-R-S-T-U.@.R.U.Z.[/#/$/@/A/Z/[:$:M:N;#;M;P;R;S<#<$<O<P<R<S=&='>#>$>&>'?!?$?L@!@&@'@(@)@J@K@LA#A$A%A)AIA^A_B&BIBJB^C%C&C_C`CaDaFDFEFFGDGVGWHEHVHWKWLVLXMUMYNYPVPYQVQYRVRWRXUFUGUHVEVIWDWJWeXfYCYKYdYeYfZCZK]D]J^E^I_F_G_H`b`c`i`jabacajbic_c`cicjd_d`gbgchbhc">Elijah's p3600 gun (Record)</option>
            <option value="!<!=!Y!]!^#<#Y#Z#[#]#_$=$_%&%<%=%W%X%Y%Z%[%]%^%`%a&&&'&(&>&?&V&^&`&c')'<'='@'V'W'Z'['^'b'c((()(=(?(Q(R(Z([(^(_)#)$)¶);)=)?)@)Q*$*+*-*;*<*S+$+&+++.+O+P+Q+R+S¶%¶&¶¶¶-¶O-R-S-T-U.R.U.Z.[/#/$/Z/[:$:M:N;#;M;P;R;S<#<$<O<P<R<S=&='>#>$>&>'?!?$?L@!@&@'@(@)@J@K@LA#A$A%A)AIA^A_B&BIBJB^C%C&C_C`CaDaFDFEFFGDGVGWHEHVHWKWLVLXMUMYNYPVPYQVQYRVRWRXUFUGUHVEVIWDWJWeXfYCYKYdYeYfZCZK]D]J^E^I_F_G_H`b`c`i`jabacajbic_c`cicjd_d`gbgchbhc">Elijah's p7680 gun (Record)</option>
            <option value="!<!=!Y!]!^#<#Y#Z#[#]#_$=$_%&%<%=%W%X%Y%Z%[%]%^%`%a&&&'&(&>&?&V&^&`&c')'<'='@'V'W'Z'['^'b'c((()(=(?(Q(R(Z([(^(_)#)$)¶);)=)?)@)Q*$*+*-*;*<*S+$+&+++.+O+P+Q+R+S¶%¶&¶¶¶-¶O-R-S-T-U.R.U.Z.[/#/$/Z/[:$:M:N;#;M;P;R;S<#<$<O<P<R<S=&='>#>$>&>'?!?$@!@&@'@(@)A#A$A%A)A^A_B&B^C%C&C_C`CaDaFDFEFFGDGVGWHEHVHWKWLVLXMUMYNYPVPYQVQYRVRWRXUFUGUHVEVIWDWJWeXfYCYKYdYeYfZCZK]D]J^E^I_F_G_H`b`c`i`jabacajbic_c`cicjd_d`gbgchbhc">Elijah's p8160 gun (Record)</option>
            <option value="!?!@#)#/#;#<#>#A$)$*$+$/$:$<$>$?$A%¶%A%C&%&&&+&¶&=&>&@&B&C'&'='>'@(&(((@)')()@)A+*++¶)¶¶¶e¶f-*-¶-e-g.+.g.l.m/c/d/e/f/h/i/l/o:]:^:c:f:h:j:l:n:o;);*;];f;h;j;l<!<#<%<'<*<_<g<h<j<l=!=$=%='=(=)=Z=[=]=^=_=k>&>Z?&?(?)?^?_?`?a@'@)@^@a@f@gAfAgBXBYCXC[C^C_DZD[D^D_GWHUHVHWITIiIjJTJUJiKjKkKlLlNONPNQOOObOcPPPbPcScTbTdUaUeVeXbXeYbYeZbZcZd^Q^R^S_P_T`O`U`paqbNbVbobpbqcNcVeOeUfPfTgQgRgShmhnhthuiminiujtkjkkktkuljlkomonpmpn">Elijah's p6960 gun (Record)</option>
            <option value="!'!)!*#'#(#*)!)#)))**!*#*)**¶&¶'-&-'<B<C<E<F=A=G>A>H>K>L?A?B?C?G?K?L@FQEQFRFSCSDSETCbecdcfdddfeeg`gagigjh_hbhhhki`iaiiijkeldlfmdmfneq|rzr{r|sytytzz©zª{©{ª~°~±¡°¡±£©£ª¤©¤ª©wªw¯v¯x°w±wµw¿wÀvÀxÁwÁÃÁÄÁÅÂwÂÂÂÅÃÂÃÅÄËÄÌÅÂÅÌÆÂÆÆÆËÇÃÇÅÇËÇÌÈÄËÄËÅÌÄÌÅ">Elijah's p4080 gun</option>
            <option value="!&!'#&#'¶&¶'¶(-%-).$.*/$/*:';%;)<&<'<(='@$@%@&A$A%A&B#B'D!D#D'D(N$N%O$O%">P30 Gosper glider gun</option>
            <option value="!!!##!##&%&&'%'&)!)#*!*#A¶A-A.B+B.C+C.D>D?E+E?F+F/F>G¶G.G>G?H-K-K.L-L.">P120 Simkin glider gun</option>
            <option value="!+#)#*#+$(%(%)'&(%(')$)(*%*&*'+#+$+(+)-D-E.D///:/B/D:/:<:B:C;&;';(;);*;+;=<%<¶<==%=*=+==>&>'>/><?/?:@%A%C+C¶D!D#D'D(D+D¶J!J#J'J(M%N%Q$Q¶R$R%R+R¶S$S%S&S*S+S¶T&T'T)T*U&U*V#V$V¶V-W#W$W¶W-X'X)Y#Y&Y*Y-Z$Z%Z&Z*Z+Z¶[&[*]&]'])]*^'^)_%_'_)_+`%`&`*`+">P690 glider gun</option>
            <option value="!+!¶!A!B#*#-#@#C$*$+$¶$/$:$;$<$=$>$A$B$C%-%.%?%@&¶&A'¶'-'/'>'@'A(;(</I/J:I;G;I<G<H=!=#=;>!>#>:><>K>L>T?/?:?<?=?K?L?R?S?T@QAQARD/D:D<D=E!E#E:E<F!F#F;NJNKOJPKPLPMQ;Q<QMR¶R-R/R>R@RAS¶SAT-T.T?T@U*U+U¶U/U:U;U<U=U>UAUBUCV*V-V@VCW+W¶WAWB">P44 Glider gun</option>
            <option value="!>!A!D#>#?#@#A#B#C#D%>%?%@%A%B%C%D&>&A&D¶@¶C-@-C-F-G.-...@.C.F.G/-/.;!;#;%;&<#<%<¶<-<.=#=%>!>#>%>&>O>P>R>S?#?%?¶?-?.?P?R@#@%@G@H@I@P@RA!A#A%A&AOAPARASBPBRCGCHCICPCRDODPDRDSFGFHG.G/G<G?GGGHH.H/H<H?I<I?M/M:M;N/N:N;O:P:Q:R/R;U/U;V:W:X:Y/Y:Y;Z/Z:Z;">P45 Glider gun</option>
            <option value="!!!#!)!*#!###)#*:!:#:):*;!;$;%;';(;*<#<%<'<)=#=%='=)>!>*B$B%B'B(C!C%C'C*D!D#D$D(D)D*E#E)G!G#H!H#I=I>J<K;K>K?KJKKL;L>LJLKM;M=N<N=P<P=Q;Q=R;R>RJRKS;S>S?SJSKT<U=U>">P46 edge shooter</option>
            <option value="ZÄZÅ[Ä[ÅeÃeÄeÅfÂfÆgÁgÇhÁhÇiÄjÂjÆkÃkÄkÅlÄoÅoÆoÇpÅpÆpÇqÄqÈsÃsÄsÈsÉ}g}h}Æ}Ç~g~h~Æ~Ç£j¤i¤Â¤Ã¥i¥Â¥Ã¨e¨f¨j¨k©hªeªk¯f¯g¯i¯j°g°i±hµh¿¿¿À¿Ä¿ÅÁÀÁÄÂjÂÁÂÂÂÃÃiÃjÃkÃÁÃÂÃÃÄhÄlÅgÅiÅjÅkÅmÆhÆiÆjÆkÆlÆÀÇ¿ÇÀÇÁÈµÈÂÉÀÊ±ÊÃË±ËÃÌµÌÂÍ¿ÍÀÍÁÑiÑjÒiÒjÖÀÖÁ×À×Á">LWSS gun w/ gliders</option>
            <option value="!C!D#C$=$>$@$A$C%;%>%@%B&;&<&A&O'M'N'O(L)D)E)F)G)H)L)M*D*E*F*G*H+.+/+B¶-¶/¶B¶C¶G¶H¶K¶L-¶-@-A-C-K-L.+.C.F.G.H/+/¶/@/E:A:B:C:D:E;%;&;D;O<&<@<B<M<N<O=$=L>$>%>->@>A>B>L>M?¶?-?.?Q?R@$@%@¶@.@/@QA$A&A/A:ASB%B¶B.B/BRBSC!C#C$C¶C-C.D!D-DJDKDLDRDSEJEQESFJFKFLFRGSGTGUHUJ@JBK¶K-KCL(L)L¶L-LCM'M)M@MCN'NANBNCO&O'OJOKPJPKPNPOQNQPRPSPSQ">P46 Gliderless LWSS gun</option>
            <option value="}d}e~d¡^¡_¡a¡b¡d¢]¢_¢a¢c£]£b£p¤[¤]¤n¤o¤p¥W¥X¥m¦X¦m¦n§X§Z¨Y¨Z©`©a©c©d©l©mª`ªdªlªm¯a¯b¯cµn¿l¿m¿nÀkÁkÁlÂoÃoÃpÃqÄrÅqÅrÇqÇrÈlÈpÈrÉkÉlÉmÉqÊkÊmÊrÊsÊtËtÒiÒjÓiÓjÓmÓnÔmÔoÕoÖoÖp">P46 Gliderless MWSS gun</option>
            <option value="!##!#$$!$%%#%$'!'((#('())!)#)')**!*&*'**">Loafer ship</option>
            <option value="!)!;!<!=!>#)#:#>$%$($?%#%%%&%(%)%*%:%;%?&!&#&%&&&-&.&?'!'#'%'&'-'.'?(#(%(&((()(*(:(;(?)%)()?*)*:*>+)+;+<+=+>">Fireship</option>
            <option value="!%!&#&$$%$%%%&%'%(%A&)&A'&'''('?'A(%(?(@)%)&)')(*#*$*(*¶*-+!+%+&+'+¶+-¶!¶#¶%-%.%.&;-;.<.=+=¶=->+%B">Snark (Stable glider turner)</option>
            <option value="!+!¶#¶$*$:$;%*%+%;&;&=&>'*'+'.'/';'>(*(+(/(;(<)/*.*/¶>¶?-?.?.A.B/-/./=/>/?/B:-:.:<:@:A;<;=;>;?<$<%<?=#=%=<===>>#>;?!?#?<?=?>???@@@A>B>B?">Semi-Snark (reflects every other glider)</option>
            <option value="!'!(#'#(&:&;'/';(:+'¶(¶¶¶--&-'-(-¶--.;.</;/=:=;$;%;=;><%=!=#=$=+=¶>!>+>¶">CC Semi-Snark (reflects every other glider)</option>
            <option value="!/#-#.#/$¶%¶%-'?'@(?(A)A*A*C*D+-+.+>+?+A+C¶-¶.¶>¶?¶A¶C-A-C-D.$.%.>.?.@.A.D/#/%/>/B/C:#:@:A;!;#;A<?=?=@">Tremi-Snark (reflects every third glider)</option>
            <option value="!+!¶#¶$*$:$;%*%+%;&;&=&>'*'+'.'/';'>(*(+(/(;(<)/*.*/+?+@¶?¶A-A.).A.C.D/*/-/./>/?/A/C:(:):*:-:.:>:?:A:C;A;C;D<$<%<><?<@<A<D=#=%=>=B=C>#>@>A?!?#?A@?A?A@">Quadri-Snark (reflects every fourth glider)</option>
            <option value="!&!'#'$'$)%(%)&-'¶'.($(¶(.)!)$)-*#*$¶>¶?->.<.>/</=/B/D:B:C:E;E<B<C<D<F<G<I=$=%=A=D=F=H=I>#>%>A>B?#@!@#A@B?BAC?CBD@DAF*F+FCFDG+GCGEH+H-H.HEI(I)I+I-I.I?I@IEIFJ(J*J?K*K¶K-K/K;K<K@KAKBL*L-L/L:L<LBM+M¶">Quinti-Snark (reflects every fifth glider)</option>
            <option value="!@#>#?#@$=$H$I%=%>%H%J&E&F&H&J'E'G'I(G)')()F)G*&*)*@*E*F*G+'+(+?+A+E+F+G¶?¶A¶E¶F¶G-@-E-F-G.$.%.F.G/%/G:!:#:$:E:G:I;!;E;F;H;J<=<><H<J=(=)===H=I>'>)>>>?>@?)?@">P4 Quinti-Snark (reflects every fifth glider)</option>
            <option value="!!!###$#$%$&%$%(&)'&'''+((())()))+)¶*(*)+)+-¶+¶---/(:':);';*<#<$<%<(<)=%>$?¶?-@¶@.A-B$B%B¶B-C#C&C*C+C¶D$D%D'D*D¶E&E'E(E*E¶F&F(F+F¶F-G%G&G(G.H$H'H-H.I%I&">P3 bumper</option>
            <option value="!-!.#-$*$+$-%'%¶&&&+'&'*'+'¶('(¶(-)¶*-*.*/+'+/¶&¶(-&-).!.#.$.'.(/$:#;+;¶<+<-=->->.">P4 bumper</option>
            <option value="!+!¶#'#(#+$&$)$+%!%#%%%'%)%+%¶&!&$&%&+'''(')'-(#($(%(&(((*(+(¶(.)!).*#*$*%*+*¶*-+%++¶&¶'¶(¶)¶*;(<'<)='=*>#>$>%>(>)?%@$A¶A-B¶B.C.D.D/">P5 bumper</option>
            <option value="!¶!-#¶#-&¶&-&.'''('+'-'.('(((+(¶)+)¶-'.&.(/&/):!:#:$:':(;$<#=+=¶>+>-?-@-@.">P6 bumper</option>
            <option value="!/#.#:$-$;%¶%:&+&/'*'.(+(-)¶*(+#+$+'+)¶!¶$¶'¶(-$-+-¶.+.-/&/'/-:&:':-:.">P8 bouncer</option>
            <option value="!¶#'#(#)#+#¶#/#:$'$($)$*$/$:%+%¶)'*&*(+&+)¶!¶#¶$¶'¶(-$.#/+/¶:+:-;-<-<.">P8 bumper</option>
            <option value="!/#.#/#:$'$($)%&%(%)&&&*&.&/&:'''*(.(:).):*'**+&+*+.+/+:¶&¶(¶)-'-(-).../.://;(<#<$<'<)=!=$='=(>$>+>¶?+?-@&@'@-A&A'A-A.">P15 bouncer</option>
            <option value="!+!¶#$#*$#$'$($+%#%(%¶&$&&&*&-')'*'+'¶)))*)+)¶*$*&***-+#+(+¶¶#¶'¶(¶+-$-*.+.¶;'<&<(=&=)>!>#>$>'>(?$@#A+A¶B+B-C-D-D.">P7 bumper</option>
            <option value="!'!(#'#(.%.&.*.+/'/(/):&:*;';)<(?*?+@*A!A#A$A+A¶A-B$B-C#">P30 buckaroo</option>
            <option value="!&!*#%#'#)#+$&$'$)$*&#&-'!'$'¶'.(!(&('()(*(.)#)')))-*$*%*'*)*+*¶+&+*-/./.:/./:">P16 filter</option>
            <option value="!#!$!*!+###$#*#+&#&+'!'#'$'*'+'¶(!(¶)#)$)%)))*)++&+(/#/$/*/+:#:$:*:+">P14 shuttle (duoplet sparker)</option>
            <option value="!-!.#¶#.$*$+$¶%*%+%-%.%/%:&+&-&;'¶'/'<(¶(-(.(/(:(;*)***-*.*/+)+*+¶+-+/+:+;¶*¶+¶-¶<-*-+-.-/-:-;-<.%.*.+.-/$/&/*/+/¶/.///;/<:&:+:/:;;&;¶;-;/;;<!<&<-</<;<<=!=&=-=/>&>¶>->/?&?+?/?;?<@$@&@*@+@¶@.@/@;@<A%A*A+A-B*B+B.B/B:B;B<C*C+C-C<D)D*D¶D-D/D:D;E)E*E-E.E/G¶G-G.G/G:G;H¶H/H<I+I-I;J*J+J-J.J/J:K*K+K¶L¶L.M-M.">P10 domino fountain</option>
            <option value="!&!'#&#'%$%%%&%'%(%)&#&*'$'%'&')'*)&*#*&+&¶&¶)¶*-!-&-).!.&.*/&/)/*:&;#;&<&>$>%>&>)>*?#?*@$@%@&@'@(@)B&B'C&C'">P4 domino sparker</option>
            <option value="!#!$#$$!&!&$'$'%($(%('((*#*(+#+)¶$¶(¶)-(-)">P6 blonker</option>
            <option value="!$!%!'!(#%#'$'%$%'%)%*&#&$&%&'&)'!'&''')(#($(()%)&)'*%">P6 thumb</option>
            <option value="!)!*#(#+$)$*%&%'%(%+%¶%-&&&)&.'(')'+'¶'-()(+)%)&)))**$*%*&¶'-'.!.'/!/':';'=$=%=&>%>&>)>*?)?+@(@)@+@¶@-A&A)A.B&B'B(B+B¶B-C)C*D(D+E)E*">P6 domino fountain</option>
            <option value="!#!&!'###$#'$!$#$$$%$&'!'#'$'%'&(#($(')#)&)'">P5 domino sparker</option>
            <option value="!#!$!%#'$!$'%&&#&$'#(#)#">P3 caterer</option>
            <option value="!;#/#:#;$.%.%/)+)¶)-***+*-*.+*+++-+.¶*¶+¶¶¶-¶.-)-*-.-/<-<.<E<F=E>>>C>E?=???C?D@=@>@@A=A>A@AAB=B>B@C=C?D>I#I$J!J$K$">P30 G to LWSS</option>
            <option value="!(!*#+#=$'$+$;$<$=%+%:&(&+&:&;'!'#'$')'*'+(#($(%¶#¶$¶%¶.-!-#-$---/.-.//.:':(:>:?;&;(;>;@<&<@=%=&=@=A">45-degree MWSS to G</option>
            <option value="!)!+#($($¶%(&(&+'(')'*(!(#)!*#*$*%+%¶#¶$-#-(-).$.(.)/#/$">135-degree MWSS to G</option>
            <option value="¢W¢X£W£X§^¨]¨_©^©_ª^°j°k±j±lµl¿l¿mÂ`ÂaÃ_ÃbÄ`Äa">HF crazy catalyst</option>
            <option value="GpGqGwHqHuHvHwIoItJoJpJtJuLoLpMnMpMsMtNnNoNsNtRsSjSrStTiTkTrTtUjUkUqUrUtUuVjVpVsWqWsXpXqXsXuXvYoYrYtYvZoZpZt[p[r[t]o]r]s^o^p">HF pusher catalyst</option>
            <option value="isitjtktkvlulvlzmym{nzn{ozqsqtrsrtw£w¤xwxxx£x¥ywy|y}y¥zxz|z}z¥z¦{y|w|y|z|{|||}}v}x}}~v~x~{¡w¡{¡|">HF pusher + glider</option>
            <option value="údúeúmûdûlûnüaübüdümünýaýdýeýfýmþbþcþgÿdÿeÿfÿgÿvÿwĀdĀvābādāfāgākālāpāqāwāxāyĂbĂcĂfĂlĂpĂyăfăhăjălănăpărĄgĄhĄjĄkĄmĄoĄqĄrąmąoĆmĆoćn">HF to beehive</option>
            <option value="!N!O#N$L$N%L%M):*:*;*<+=+D+E+F¶<¶=¶F-E-F-G.N.O/N/O<!<#=#>#>%?$?%D#D$E#E$FJFKGJGKK¶L+L-M+M¶YDYEZDZE">Block keeper (Hershel input)</option>
            <option value="!&!>#$#&#<#=#>$%$&$;%;%<&!&#'#(#(%)$)%):*(*)*/*;+'+*+/+;¶(¶)¶:¶?¶@-$-%-?-A.#.%.A/#///A/B:!:#:.:/;.;:@-@.A-A.K+K¶K-L-M-M.">Syringe (G to H)</option>
            <option value="!_#]#^#_$'$)$*$[%'%(%*%S%T%[%]&S&U'T*(*a*b+!+#+'+++¶+-+X+Y+a+b¶!¶#¶&¶-¶X¶Y-'--.(.).+.¶.O.P/O/P;_;`<_<a=G=H=a>G>H>a>b>i?g?h?i@D@E@K@L@fADAEAKALAfAgBVBWCWDWDYEXEYEeFdFfGdGfHeHjHkIXIYIjIlJPJQJWJYJlJvKPKWKlKmKuKwLNLPLVLWLtLxMNMOMsMwNrNvO?O@OqOuP?P@PrPtQsRHRIRbRcRoSHSISPSQSbScSnSpTPTQTnToUrUsVrVtWDWmWnWtXCXEXmXnXtXuYCYDYKYLZK[L[M[N[U]N]U]V]W^G^H^X_H_W_X`H`JaIaJajakbjbkeGeHfHgHgJhIhJmHmInHnIofogpfpgtQuPuRvPvQ¤`¤a¥`¥a">Constant block keeper</option>
            <option value="!;!=#>$>%;%>&<&=&>())()**'*(***++#+$+*++¶#¶$¶%¶*¶+-!-$-%-*-+-¶.!.#.$/#;+<)<*<+<¶=#=%=(=¶=;==>!>(>+>:?!?)?*?+?:@!@%@:@=A!A#A$A:A;A<">Frontrake</option>
            <option value="!'!)#&#)$%$&%$&#&$&%&&'!''(!(%(+(¶(-)!)%)+*#*+*-+$+%+&+'+)¶%¶)¶¶-&-:-;.&.'.(.).*...=/-:&:':(:):*:-:=;&;-;.;/;:;;;<<%<)=$=%=&='=)>#>+?!?%?+@!@%@+@¶@.A!A'A.B#B$B%B&C$D%D&E&E)F'F)">Backrake</option>
            <option value="YÆYÇZqZrZÆZÇ[p[q[r[s^o^p^q^r^s^t^Æ_p_q_r_s_Å_Ç_Í_Î`Ä`È`ÍaoapasataÄaÎbmbnbpbsbubvbÍbÎcpcscÄcÇdÄdÇeÅeÆeÇfqfrgqgrinipisiujmjpjsjvkmkvlmlvmmmnmumvnonpnqnrnsntr¯r°s¯s°uµu¿vµv¿y¯y°z¯z°¤°¤±¥°¥±¨©¨ª©©©ª©Ã©ÄªÃ¯°¯±¯Ä°°°±°Ã°ÄÀ¡À¢À£Â¡Â£Ã¤Ä~Ä¤Æ~Æ£Æ¤Ì¡Ì¢ÍUÍVÍ¡Í¢ÎTÎVÏTÏ¤Ï¥ÐSÐTÐ¤Ð¥Ó¡Ó¢ÔTÔUÔ¡Ô¢ÕTÕUØQØRØ{Ø|ÙQÙRÙ{Ù|ÛTÛUÜTÜUÜ~Ü¡Ý~Ý¡ß{ß|à{à|ãRãSåRåSæzæ}æ~çSçUèTèzè~éTé~ê{ê}ìBìCìIìJì{ì|ì}íBíIíJîCïBïCïLïMðLðMð¨ð©ð¿ðÀñ¨ñ©ñÀò¿óIóJó¥ó¦ó¿óÀôIôJô¥ô¦÷¨÷©ø¨ø©ùIùJúIúJýLýMþBþCþLþMÿCĀBĀIĀJāBāCāIāJąSąTąUćSćUĈRĉRĉVċRċSċVđTđUđkđlđmĒTĒUĒjĒmēmĔQĔRĔmĕQĕRĕjĕlĘTĘUęTęUę¡ę¢Ě¡Ě¢ĝXĝYĝ¤ĝ¥ĞXĞYĞ¤Ğ¥Ġ¡Ġ¢ġUġVġ¡ġ¢ĢUĢVĤXĤYĥXĥYĨ£Ĩ¤Ī£Ī¤īVīWīZĬ¡Ĭ£ĭVĭZĭ¢ĮVĮ¢įWįYıWıXıYı°ı±ıÃıÄĲ°Ĳ±ĲÄĳÃĴ©ĴªĴÃĴÄĵFĵGĵMĵNĵ©ĵªĶFĶMĶNķGĸFĸGĸPĸQĸ°ĸ±ĹPĹQĹ°Ĺ±ļMļNĽMĽN">Elijah's sawtooth</option>
            <option value="@¢@£A¢A£X¨YzY{Y|Y§Y¨Y©ZzZ}Z¦Z§Z©[z[¦[§[¨]z]~]¦]§]¨^z^§^¨_{_}bycxcyczdwdxdzewexeyfwfxfygxgyo¤o¥o¦p£p¦q¦r¢r¦s¦t£t¥¢r¢s¢t¢~£q£t£}£~£¡¤t¤|¤}¤¡¥p¥t¥|¥}¥~¦t¦|¦}¦~§q§s§}§~¯¡¯¢¯£°~°£±£µ}µ£¿£À~À¢ÇvÈuÈvÈwÉuÉwÉxÊvÊwÊxËvËwËxÌvÌwÙ¨ÚzÚ{Ú|Ú§Ú¨Ú©ÛzÛ}Û¦Û§Û©ÜzÜ¦Ü§Ü¨ÝzÝ~Ý¦Ý§Ý¨ÞzÞ§Þ¨ß{ß}âyãxãyãzäwäxäzåwåxåyæwæxæyçxçyï¤ï¥ï¦ð£ð¦ñ¦ò¢ò¦ó¦ô£ô¥ĀrĀsĀtĀ~āqātā}ā~ā¡ĂtĂ|Ă}Ă¡ăpătă|ă}ă~ĄtĄ|Ą}Ą~ąqąsą}ą~ĉ¡ĉ¢ĉ£Ċ~Ċ£ċ£Č}Č£č£Ď~Ď¢ĕvĖuĖvĖwėuėwėxĘvĘwĘxęvęwęxĚvĚw">Non-destructive MWSS block pull</option>
        </select>
        <button id="add">Add</button>
        <button id="save">Save</button>
        <button id="import">Import</button>
        <button id="edit">Edit</button>
        <button id="clearpart">Clear</button>
        <button id="copy">Copy</button>
        <button id="move">Move</button>
        <button id="tile">Tile</button>
    </div>
    <br>
    <details>
        <summary>Settings</summary>
        <input id="reset" type="checkbox" checked>
        <label for="reset">Reset generation counter and back button on change</label>
        <br>
        <input id="track" type="checkbox">
        <label for="track">Show previous cells</label>
    </details>
    <details id="source">
        <summary>Source & licence</summary>
        Many of the library items are from or derived from <a href="https://playgameoflife.com/lexicon" target="_blank">this game of life website</a> and are licenced under <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">Creative Commons Attribution-ShareAlike 3.0 Unported</a> licence.
    </details>
    <div id="spacer"></div>
    <script>
let boxSize = 6;
/* Variables */
let buttons    = document.querySelectorAll("button");
let nextB      = document.querySelector("#next");
let randB      = document.querySelector("#randomize");
let clearB     = document.querySelector("#clear");
let startB     = document.querySelector("#start");
let backB      = document.querySelector("#back");
let addB       = document.querySelector("#add");
let saveB      = document.querySelector("#save");
let importB    = document.querySelector("#import");
let editB      = document.querySelector("#edit");
let clearPartB = document.querySelector("#clearpart");
let copyB      = document.querySelector("#copy");
let moveB      = document.querySelector("#move");
let tileB      = document.querySelector("#tile");
let speedCount = document.querySelector("#speed-counter");
let genCounter = document.querySelector("#counter");
let runSpeed   = document.querySelector("#speed");
let pattern    = document.querySelector("#pattern");
let resetGens  = document.querySelector("#reset");
let trackPrev  = document.querySelector("#track");
let canvas     = document.querySelector("canvas");
let c = canvas.getContext("2d");

let boxes = new Map(), newBoxes = new Map(), possibleNew = new Map(), prevCells = new Map();
let savedBoard = new Map(), placingBoard = null, generations = 0;
let [minX, minY, maxX, maxY, xOff, yOff] = [Infinity, Infinity, -Infinity, -Infinity, 0, 0];
let chooseStage = null, numW = 227*1, numH = 125*1, w, h;


canvas.setAttribute("width", (w = numW*boxSize+1) + "px");
canvas.setAttribute("height", (h = numH*boxSize+1) + "px");

let MapCompressor = (function() {
    const chars = "!#$%&'()*+¶-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~¡¢£¤¥¦§¨©ª¯°±µ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋŌōŎŏŐőŒœŔŕŖŗŘřŚśŜŝŞşŠšŢţŤťŦŧŨũŪūŬŭŮůŰűŲųŴŵŶŷŸŹźŻżŽžſƀƁƂƃƄƅƆƇƈƉƊƋƌƍƎƏƐƑƒƓƔƕƖƗƘƙƚƛƜƝƞƟƠơƢƣƤƥƦƧƨƩƪƫƬƭƮƯưƱƲƳƴƵƶƷƸƹƺƻƼƽƾƿǀǁǂǃǄǅǆǇǈǉǊǋǌǍǎǏǐǑǒǓǔǕǖǗǘǙǚǛǜǝǞǟǠǡǢǣǤǥǦǧǨǩǪǫǬǭǮǯǰǴǵǶǷǸǹǺǻǼǽǾǿȀȁȂȃȄȅȆȇȈȉȊȋȌȍȎȏȐȑȒȓȔȕȖȗȘșȚțȜȝȞȟȠȡȢȣȤȥȦȧȨȩȪȫȬȭȮȯȰȱȲȳȴȵȶȷȸȹȺȻȼȽȾȿɀɁɂɃɄɅɆɇɈɉɊɋɌɍɎɏɐɑɒɓɔɕɖɗɘəɚɛɜɝɞɟɠɡɢɣɤɥɦɧɨɩɪɫɬɭɮɯɰɱɲɳɴɵɶɷɸɹɺɻɼɽɾɿʀʁʂʃʄʅʆʇʈʉʊʋʌʍʎʏʐʑʒʓʔʕʖʗʘʙʚʛʜʝʞʟʠʡʢʣʤʥʦʧʨʩʪʫʬʭʮʯʰʱʲʳʴʵʶʷʸʹʺʻʼʽˀˁ˂˃˄˅˪˫˭ˮ˵˶˸˹˺˻˼˽˾ͱͲͳʹ͵ͶͷͻͼͽͿ΄΅Ά·ΈΉΊΌΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώϏϐϑϒϓϔϕϖϗϘϙϚϛϜϝϞϟϠϡϢϣϤϥϦϧϨϩϪϫϬϭϮϯϰϱϲϳϴϵ϶ϷϸϹϺϻϼϽϾϿЀЁЂЃЄЅІЇЈЉЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљњћќѝўџѠѡѢѣѤѥѦѧѨѩѪѫѬѭѮѯѰѱѲѳѴѵѶѷѸѹѺѻѼѽѾѿҀҁ҂ҊҋҌҍҎҏҐґҒғҔҕҖҗҘҙҚқҜҝҞҟҠҡҢңҤҥҦҧҨҩҪҫҬҭҮүҰұҲҳҴҵҶҷҸҹҺһҼҽҾҿӀӁӂӃӄӅӆӇӈӉӊӋӌӍӎӏӐӑӒӓӔӕӖӗӘәӚӛӜӝӞӟӠӡӢӣӤӥӦӧӨөӪӫӬӭӮӯӰӱӲӳӴӵӶӷӸӹӺӻӼӽӾӿԀԁԂԃԄԅԆԇԈԉԊԋԌԍԎԏԐԑԒԓ";
    const RLErow = /[\dob$]{0,69}[ob$!]/gi;
    const startRLE = /^x ?= ?\d+, ?y ?= ?\d+, ?rule ?= ?b3\/s23 *\n?\r?/i;
    const extras = /x ?= ?\d+, ?y ?= ?\d+, ?rule ?= ?b3\/s23\n?\r?|\n\r?| |!/gi;
    const RLEpiece = /(\d+)([ob$])/gi;

    function compressMap(mapToCompress) {
        let result = "";
        mapToCompress.forEach(({x, y}) => {
            result += chars[x] + chars[y];
        });
        return result; 
    }

    function replaceRLEpiece(piece, count, letter) {
        return letter.repeat(Number(count || 1));
    }
    
    function decompressMap(str) {
        let result = new Map();
        
        if (startRLE.test(str)) {
            let RLE = str.replace(extras, "").toLowerCase()
                .replace(RLEpiece, replaceRLEpiece).split("$");
            for (let y = 0; y < RLE.length; y++) {
                let row = RLE[y];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] === "o") {
                        result.set(`${x} ${y}`, {x, y}); 
                    }
                }
            }
        } else {
            for (let i = 0; i < str.length;) {
                let x = chars.indexOf(str[i++]);
                let y = chars.indexOf(str[i++]);
                result.set(`${x} ${y}`, {x, y}); 
            }
        }

        return result;
    }


    function mapToRLE(mapToConvert) {
        // Get bounds
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        if (mapToConvert.size > 0) {
            mapToConvert.forEach(({x, y}) => {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });
        } else {
            minX = maxX = minY = maxY = 0;
        }
        
        // Convert
        let result = "";
        let curCount = 0;
        let curCountingChar = "";
        for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
                let nextChar = mapToConvert.has(`${x} ${y}`)? "o" : "b";
                if (nextChar === curCountingChar) {
                    curCount++;
                } else {
                    if (curCount === 1) {
                        result += curCountingChar;
                    } else if (curCount) {
                        result += "" + curCount + curCountingChar;
                    }
                    curCount = 1;
                    curCountingChar = nextChar;
                }
            }
            if (curCount === 1) {
                result += curCountingChar;
            } else if (curCount) {
                result += "" + curCount + curCountingChar;
            }
            curCount = 0;
            curCountingChar = "";
            result += y < maxY? "$" : "";
        }
        result += "!";

        // Create the header line
        let headerLine = "x = " + (maxX - minX + 1) +  ", y = " + (maxY - minY + 1) + ", rule = B3/S23";
        
        // Split into lines of no longer than 70 chars
        result = result.replace(RLErow, "\n$&");

        return headerLine + result;
    }
    
    return {compress: compressMap, decompress: decompressMap, toRLE: mapToRLE}; 
})();

function isIn(x, y, x2, y2, w, h) {
    switch(arguments.length) {
        case 3:
            return x >= -x2 && y >= -x2 && x <= x2 && y <= x2;
        case 4:
            return x >= -x2 && y >= -y2 && x <= x2 && y <= y2;
        case 5:
            return x >= x2 && y >= y2 && x <= w + x2 && y <= w + y2;
        case 6:
            return x >= x2 && y >= y2 && x <= w + x2 && y <= h + y2;
        default:
            return false;
    }
}

function drawBoard(board) {
    c.fillStyle = "#111111";
    c.fillRect(0, 0, numW * boxSize, numH * boxSize);

    for(let x = 0; x < numW; x++) {
        for(let y = 0; y < numH; y++) {
            let [newX, newY] = [x + xOff, y + yOff];
            let drawPlacingBoard = placingBoard && newX >= minX && newY >= minY && newX <= maxX && newY <= maxY;
            if (drawPlacingBoard? placingBoard.has(`${newX} ${newY}`) : board.has(`${x} ${y}`)) {
                c.fillStyle = "#308aff";
                c.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
            }
        }
    }
    
    c.fillStyle = "#333";
    for(let y = 0; y <= numH; y++) {
        c.fillRect(0, y * boxSize, w, boxSize/6);
    }
    for(let x = 0; x <= numW; x++) {
        c.fillRect(x * boxSize, 0, boxSize/6, h);
    }

    c.fillStyle = "#f02";
    let lineSize = boxSize/3;
    if (chooseStage === 1) {
        c.fillRect(minX * boxSize - lineSize/2, 0, lineSize, h);
        c.fillRect(0, minY * boxSize - lineSize/2, w, lineSize);
    } else if (chooseStage === 2) {
        let x1 = minX * boxSize, x2 = maxX * boxSize;
        let y1 = minY * boxSize, y2 = maxY * boxSize;
        c.fillRect(x1, y1, x2-x1, lineSize);
        c.fillRect(x1, y1, lineSize, y2-y1);
        c.fillRect(x1, y2, x2-x1+lineSize, lineSize);
        c.fillRect(x2, y1, lineSize, y2-y1+lineSize);
    }
}

function saveBoard(board, zoneX, zoneY, zoneW, zoneH) {
    let argNum = arguments.length;
    savedBoard.clear();
    board.forEach(({x, y}, key) => {
        if (argNum < 5 || isIn(x, y, zoneX, zoneY, zoneW, zoneH)) {
            savedBoard.set(key, {x, y});
        }
    });
}

function updateSpeedCounter() {
    let speed = runSpeed.value, perSecond = Math.round(200 / -speed);
    speedCount.textContent = `Speed: ${speed < 0? `${perSecond}/s` : `x${Math.max(speed, 1)}`}`;
}

function updateGenCounter() {
    genCounter.textContent = `Generation ${generations}`;
}

function updateAfterChange() {
    if (resetGens.checked) {
        generations = 0;
        updateGenCounter();
        saveBoard(boxes);
    }
    drawBoard(boxes);
}

function mouseCellLocation(event, canvas, round) {
    let func = round? "round" : "floor";
    let rect = canvas.getBoundingClientRect();
    let x = Math[func]((event.clientX - rect.left) / boxSize);
    let y = Math[func]((event.clientY - rect.top ) / boxSize);
    return {x, y};
}

function toggle(event, canvas) {
    if (placingBoard || chooseStage) { return; }
    let {x, y} = mouseCellLocation(event, canvas);
    
    if (boxes.has(`${x} ${y}`)) {
        boxes.delete(`${x} ${y}`);
    } else {
        boxes.set(`${x} ${y}`, {x: x, y: y});
    }
    updateAfterChange();
}

let positions = [
    {x: -1, y: -1},
    {x: +0, y: -1},
    {x: +1, y: -1},
    {x: -1, y: +0},
    {x: +1, y: +0},
    {x: -1, y: +1},
    {x: +0, y: +1},
    {x: +1, y: +1}
];

function countLiveNeighbors(i, j) {
    let count = 0;

    positions.forEach(pos => {
        let x = i+pos.x, y = j+pos.y;
        
        if(x in boxes && boxes[x][y]) {
            count++;
        }
    });
    
    return count;
}

function next() {
    newBoxes.clear();
    possibleNew.clear();

    boxes.forEach(pos => {
        let neighbors = 0;
        for (let i = positions.length; i-- > 0;) {
            let x = pos.x + positions[i].x;
            let y = pos.y + positions[i].y;
            
            if (boxes.has(`${x} ${y}`)) {
                neighbors++;
            } else if (possibleNew.has(`${x} ${y}`)) {
                possibleNew.get(`${x} ${y}`).neighbors++;
            } else {
                possibleNew.set(`${x} ${y}`, {x: x, y: y, neighbors: 1});
            }
        }
        
        if (neighbors >= 2 && neighbors <= 3) {
            newBoxes.set(`${pos.x} ${pos.y}`, {x: pos.x, y: pos.y});
        }
    });

    possibleNew.forEach(pos => {
        if (pos.neighbors === 3) {
            newBoxes.set(`${pos.x} ${pos.y}`, {x: pos.x, y: pos.y});
        }
    });
    
    [boxes, newBoxes] = [newBoxes, boxes];
    generations++;
    updateGenCounter();
    drawBoard(boxes);
}

function randomize() {
    boxes.clear();
    for(let x = 0; x < numW; x++) {
        for(let y = 0; y < numH; y++) {
            if (Math.random() < 0.5) {
                boxes.set(`${x} ${y}`, {x: x, y: y});
            }
        }
    }
    updateAfterChange();
}

function clear() {
    boxes.clear();
    updateAfterChange();
}

let running = false;
let curTimer = null;
function run() {
    if(running) {
        let times = Math.max(runSpeed.value, 1);
        for (let i = 0; i < times; i++) {
            next();
        }
        if (runSpeed.value > 0) {
            curTimer = setTimeout(run, 0);
        } else {
            curTimer = setTimeout(run, -runSpeed.value * 5);
        }
    }
}

function startRunning() {
    running = true;
    
    startB.textContent = "Stop";
    startB.id = "stop";
    startB.onclick = stopRunning;
    
    run();
}

function stopRunning() {
    clearTimeout(curTimer);
    running = false;
    
    startB.textContent = "Start";
    startB.id = "start";
    startB.onclick = startRunning;
}

function resetBoard() {
    boxes.clear();
    function setEachCell(value, key) {
        boxes.set(key, {x: value.x, y: value.y});
    }
    savedBoard.forEach(setEachCell);
    generations = 0;
    updateGenCounter();
    drawBoard(boxes);
}

function chooseBoard() {
    placingBoard = null;
    chooseStage = 1;

    return new Promise((resolve, reject) => {
        function check() {
            if (!chooseStage) {
                canvas.removeEventListener("mousemove", handleMove);
                canvas.removeEventListener("click", handleClick);
                reject("Stopped.");
            }
        }
        function updateCoords(event) {
            let {x, y} = mouseCellLocation(event, canvas, true);
            if (chooseStage === 1) {
                minX = x;
                minY = y;
            } else if (chooseStage === 2) {
                maxX = x;
                maxY = y;
            }
        }
        function handleMove(event) {
            check();
            updateCoords(event);
            drawBoard(boxes);
        };
        function handleClick(event) {
            check();
            if (chooseStage === 1) {
                updateCoords(event);
                chooseStage = 2;
            } else if (chooseStage === 2) {
                updateCoords(event);
                [minX, minY, maxX, maxY] = [Math.min(minX, maxX), 
                    Math.min(minY, maxY), Math.max(minX, maxX), Math.max(minY, maxY)];
                maxX--; maxY--;
                let board = new Map();
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        if (boxes.has(`${x} ${y}`)) {
                            board.set(`${x} ${y}`, {x, y});
                        }
                    }
                }
                chooseStage = null;
                drawBoard(boxes);
                canvas.removeEventListener("mousemove", handleMove);
                canvas.removeEventListener("click", handleClick);
                resolve(board);
            }
        };
        canvas.addEventListener("mousemove", handleMove);
        canvas.addEventListener("click", handleClick);
    });
}

function placeBoard(board, setMinMax = true) {
    if (setMinMax) {
        minX = minY = Infinity;
        maxX = maxY = -Infinity;
        if (board.size > 0) {
            board.forEach(({x, y}) => {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });
        } else {
            minX = maxX = minY = maxY = 0;
        }
    }
    placingBoard = board;
    chooseStage = null;
    xOff = 0; yOff = 0;
    drawBoard(boxes);

    return new Promise((resolve, reject) => {
        function check() {
            if (!placingBoard) {
                canvas.removeEventListener("mousemove", handleMove);
                canvas.removeEventListener("click", handleClick);
                window.removeEventListener("keydown", handleKey);
                reject("Stopped.");
                return false;
            } else {
                return true;
            }
        }
        function updateCoords(event) {
            let {x, y} = mouseCellLocation(event, canvas);
            xOff = maxX - x;
            yOff = maxY - y;
        }
        function handleKey(event) {
            if (!check()) return;
            if (event.key === 'ArrowRight') {
                let newBoard = new Map();
                let cx = Math.ceil((maxX - minX) / 2), cy = Math.ceil((maxY - minY) / 2);
                [maxX, maxY] = [maxY - minY + minX, maxX - minX + minY];
                placingBoard.forEach(({x, y}) => {
                    [x, y] = [cx + cy - y, cy - cx + x];
                    newBoard.set(`${x} ${y}`, {x, y});
                });
                let curMinX = Infinity, curMinY = Infinity;
                newBoard.forEach(({x, y}) => {
                    curMinX = Math.min(curMinX, x);
                    curMinY = Math.min(curMinY, y);
                });
                placingBoard.clear();
                newBoard.forEach(({x, y}) => {
                    let newX = x + minX - curMinX, newY = y + minY - curMinY;
                    placingBoard.set(`${newX} ${newY}`, {x: newX, y: newY});
                });
                event.preventDefault();
            } else if (event.key === 'ArrowLeft') {
                let newBoard = new Map();
                let cx = Math.ceil((maxX - minX) / 2), cy = Math.ceil((maxY - minY) / 2);
                [maxX, maxY] = [maxY - minY + minX, maxX - minX + minY];
                placingBoard.forEach(({x, y}) => {
                    [x, y] = [cx - cy + y, cy + cx - x];
                    newBoard.set(`${x} ${y}`, {x, y});
                });
                let curMinX = Infinity, curMinY = Infinity;
                newBoard.forEach(({x, y}) => {
                    curMinX = Math.min(curMinX, x);
                    curMinY = Math.min(curMinY, y);
                });
                placingBoard.clear();
                newBoard.forEach(({x, y}) => {
                    let newX = x + minX - curMinX, newY = y + minY - curMinY;
                    placingBoard.set(`${newX} ${newY}`, {x: newX, y: newY});
                });
                event.preventDefault();
            } else if (event.key === 'ArrowUp') {
                let newBoard = new Map();
                placingBoard.forEach(({x, y}) => {
                    y = minY + maxY - y;
                    newBoard.set(`${x} ${y}`, {x, y});
                });
                placingBoard = newBoard;
                event.preventDefault();
            } else if (event.key === 'ArrowDown') {
                let newBoard = new Map();
                placingBoard.forEach(({x, y}) => {
                    x = minX + maxX - x;
                    newBoard.set(`${x} ${y}`, {x, y});
                });
                placingBoard = newBoard;
                event.preventDefault();
            }
            drawBoard(boxes);
        }
        function handleMove(event) {
            check();
            updateCoords(event);
            drawBoard(boxes);
        };
        function handleClick(event) {
            if (!check()) return;
            updateCoords(event);
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    boxes.delete(`${x - xOff} ${y - yOff}`);
                    if (placingBoard.has(`${x} ${y}`)) {
                        boxes.set(`${x - xOff} ${y - yOff}`, {x: x - xOff, y: y - yOff});
                    }
                }
            }
            placingBoard = null;
            updateAfterChange();
            canvas.removeEventListener("mousemove", handleMove);
            canvas.removeEventListener("click", handleClick);
            window.removeEventListener("keydown", handleKey);
            resolve();
        };
        canvas.addEventListener("mousemove", handleMove);
        canvas.addEventListener("click", handleClick);
        window.addEventListener("keydown", handleKey);
        check();
    });
}

function add() {
    let options = document.querySelectorAll("#pattern > option");
    let str = Array.from(options).find(el => el.selected)?.value;
    if (str) {
        placeBoard(MapCompressor.decompress(str), true).catch(() => {});
    }
}

function save() {
    chooseBoard().then(board => {
        let name = prompt("What should this pattern be called?");
        if (name) {
            let compressed = MapCompressor.compress(board);
            let RLE = MapCompressor.toRLE(board);
            console.log("The compressed string is", compressed);
            console.log("The RLE is", RLE);
            let newElement = document.createElement("option");
            newElement.value = RLE;
            newElement.appendChild(document.createTextNode(name));
            pattern.insertBefore(newElement, pattern.children[0]);
        }
    }, () => {});
}

function importBoard() {
    let str = prompt("Enter compressed string.");
    if (str) {
        placeBoard(MapCompressor.decompress(str), true).catch(() => {});
    }
}

// function edit

function clearPart() {
    chooseBoard().then(() => {
        for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
                boxes.delete(`${x} ${y}`);
            }
        }
        updateAfterChange();
    }, () => {});
}

function move() {
    chooseBoard().then(board => {
        for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
                boxes.delete(`${x} ${y}`);
            }
        }
        updateAfterChange();
        placeBoard(board, false).catch(() => {});
    }, () => {});
}

function copy() {
    chooseBoard().then(board => {
        placeBoard(board, false).catch(() => {});
    }, () => {});
}

function tile() {
    chooseBoard().then(tileWith => {
        let tileSize = {x: maxX - minX + 1, y: maxY - minY + 1, xOff: minX, yOff: minY};
        chooseBoard().then(() => {
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    let tileX = (x - minX) % tileSize.x + tileSize.xOff;
                    let tileY = (y - minY) % tileSize.y + tileSize.yOff;
                    if (tileWith.has(`${tileX} ${tileY}`)) {
                        boxes.set(`${x} ${y}`, {x, y});
                    } else {
                        boxes.delete(`${x} ${y}`);
                    }
                }
            }
            updateAfterChange();
        }, () => {});
    }, () => {});
}

document.addEventListener("keyup", function(event) {
    event.target.blur();

    let key = event.key.toLowerCase();
    
    for(let i = 0; i < buttons.length; i++) {
        if(buttons[i].id[0].toLowerCase() === key) {
            buttons[i].click();
           break;
        }
    }
});

window.addEventListener("beforeunload", event => {
    event.preventDefault();
    //event.returnValue = "Any unsaved changes will be lost!";
});

nextB.addEventListener("click", next);
randB.addEventListener("click", randomize);
clearB.addEventListener("click", clear);
startB.onclick = startRunning;
backB.addEventListener("click", resetBoard);
addB.addEventListener("click", add);
saveB.addEventListener("click", save);
importB.addEventListener("click", importBoard);
// editB.addEventListener("click", edit);
clearPartB.addEventListener("click", clearPart);
copyB.addEventListener("click", copy);
moveB.addEventListener("click", move);
tileB.addEventListener("click", tile);
runSpeed.addEventListener("input", () => { updateSpeedCounter(); })

updateSpeedCounter();
randomize();
drawBoard(boxes);
        </script>
    </body>
</html>
